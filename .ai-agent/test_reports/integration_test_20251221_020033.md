# ü§ñ AI Code Agent - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –¢–µ—Å—Ç

**–î–∞—Ç–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:** 21.12.2025 02:00:33
**–ü—Ä–æ–µ–∫—Ç:** `C:\Users\Admin\AI_Assistant_Pro`
**–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:** 498.62 —Å–µ–∫.

---

## üìù –ó–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

> –Ø —Ö–æ—á—É –≤–Ω–µ–¥—Ä–∏—Ç—å –µ—â–µ –æ–¥–Ω—É –º–æ–¥–µ–ª—å –ò–ò –¥–ª—è –û—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (–ø—Ä–æ—Å—Ç–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–∞–∫ Deepseek V3.2 —Ä–∞—Å—Å—É–∂–¥–∞—é—â–∏–π), –∞ –∏–º–µ–Ω–Ω–æ Gemini 3.0 pro. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞, –æ—Å–æ–±–µ–Ω–Ω–æ settings.py, orchestrator.py, api_client.py –∏ —É–∫–∞–∂–∏, —É—á–∏—Ç—ã–≤–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å —ç—Ç–æ–π –º–æ–¥–µ–ª–∏ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏ (–Ω–∞–¥–æ –ø–∞—Ä—Å–∏—Ç—å –∏ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å Thought Signatures –Ω–∞–∑–∞–¥), —Ç–æ –∫–∞–∫ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –≤–Ω–µ–¥—Ä–∏—Ç—å —ç—Ç—É –º–æ–¥–µ–ª—å, —á—Ç–æ–±—ã –Ω–µ –∏—Å–ø–æ—Ä—Ç–∏—Ç—å —Ä–∞–±–æ—Ç—É –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π. –í–∞–∂–Ω–æ (!) –∏—â–∏ –≤ –ò–Ω—Ç–µ—Ä–Ω–µ—Ç–µ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –∏–º–µ–Ω–Ω–æ –Ω–∞ –º–æ–¥–µ–ª—å Gemini 3.0 pro! –ü–æ—Å–ª–µ –∞–Ω–∞–ª–∏–∑–∞, –Ω–∞–ø–∏—à–∏ –∫–æ–¥ —Ä–µ—à–µ–Ω–∏—è –∏ —É–∫–∞–∂–∏, –∫—É–¥–∞ –µ–≥–æ –≤—Å—Ç–∞–≤–∏—Ç—å.

---

## üéØ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏

- **Orchestrator:** DeepSeek V3.2 Reasoning
- **Code Generator:** deepseek-chat

---

## üîç –ê–Ω–∞–ª–∏–∑ –û—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–∞

–ü–æ—Å–ª–µ –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –≤–µ–±-–ø–æ–∏—Å–∫–∞ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Gemini 3.0 Pro, —è –≤—ã—è–≤–∏–ª —Å–ª–µ–¥—É—é—â–µ–µ:

**–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ**: –ú–æ–¥–µ–ª—å Gemini 3.0 Pro —É–∂–µ —á–∞—Å—Ç–∏—á–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ:
1. –í `config/settings.py` –µ—Å—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è `MODEL_GEMINI_3_PRO = "google/gemini-3-pro-preview"`
2. –í `MODEL_CONFIGS` –µ—Å—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å `extra_params: {"reasoning_effort": "high"}`
3. –ú–æ–¥–µ–ª—å —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–∞

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Gemini 3.0 Pro**: Thought Signatures (–ø–æ–¥–ø–∏—Å–∏ –º—ã—Å–ª–µ–π)
- –≠—Ç–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏—è –º–æ–¥–µ–ª–∏
- **–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã** –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏ (tool calls)
- –ë–µ–∑ –Ω–∏—Ö –ø–æ–ª—É—á–∞–µ—Ç—Å—è –æ—à–∏–±–∫–∞ 400: "Function call is missing a thought_signature"
- –î–æ–ª–∂–Ω—ã —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è –∏ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å—Å—è –æ–±—Ä–∞—Ç–Ω–æ –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö

**ROOT CAUSE**: –¢–µ–∫—É—â–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è `LLMClient` –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ `reasoning_content` –¥–ª—è DeepSeek, –Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç `thought_signature` –¥–ª—è Gemini 3.0 Pro. –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å Gemini, —Å–∏—Å—Ç–µ–º–∞ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–µ—Ç thought signatures –æ–±—Ä–∞—Ç–Ω–æ, —á—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ä–∞–∑—Ä—ã–≤—É —Ü–µ–ø–æ—á–∫–∏ —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π –∏ –æ—à–∏–±–∫–µ 400.

**–ü—Ä–æ–±–ª–µ–º–∞ –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ**:
1. `LLMClient._parse_response()` –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–æ–ª—å–∫–æ `reasoning_content` –¥–ª—è DeepSeek
2. –°–∏—Å—Ç–µ–º–∞ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç `thought_signature` –∏–∑ –æ—Ç–≤–µ—Ç–æ–≤ Gemini
3. –ü—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –∑–∞–ø—Ä–æ—Å–µ –ø–æ–¥–ø–∏—Å–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è, –ª–æ–º–∞—è —Ü–µ–ø–æ—á–∫—É —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π

**–†–µ—à–µ–Ω–∏–µ**: –ù—É–∂–Ω–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∏ –∫–ª—é—á–µ–≤—ã—Ö —Ñ–∞–π–ª–∞ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ Thought Signatures:
1. `app/llm/api_client.py` - –∏–∑–≤–ª–µ–∫–∞—Ç—å –∏ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å thought signatures
2. `app/tools/tool_executor.py` - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å thought signatures –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –≤—ã–∑–æ–≤–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
3. `app/agents/orchestrator.py` - –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å thought signatures –≤ –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π

---

## üìã –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è Code Generator

**SCOPE:** Multiple files

**Task:** –î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∫—É Thought Signatures –¥–ª—è Gemini 3.0 Pro –≤ —Ü–µ–ø–æ—á–∫–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤

---

---

## üíª –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥

### –ë–ª–æ–∫ 1

**–§–∞–π–ª:** `app/agents/thought_signature.py`

```python
"""
Thought Signature support for Gemini 3.0 Pro in tool processing chain.

This module provides functionality to generate and validate thought signatures
for Gemini 3.0 Pro API responses when using tools/function calling.
"""

import hashlib
import json
import time
from typing import Any, Dict, Optional, Union
from dataclasses import dataclass, asdict


@dataclass
class ThoughtSignature:
    """Represents a thought signature for Gemini tool processing."""
    
    model: str
    timestamp: float
    tool_calls_hash: str
    reasoning_hash: Optional[str] = None
    signature: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ThoughtSignature':
        """Create ThoughtSignature from dictionary."""
        return cls(**data)


class ThoughtSignatureGenerator:
    """Generates thought signatures for Gemini 3.0 Pro tool calls."""
    
    def __init__(self, model: str = "gemini-3.0-pro"):
        """
        Initialize the thought signature generator.
        
        Args:
            model: The Gemini model name (default: "gemini-3.0-pro")
        """
        self.model = model
        self._secret_salt = "gemini_thought_signature_v1"
    
    def generate_tool_calls_hash(self, tool_calls: list) -> str:
        """
        Generate hash for tool calls to ensure integrity.
        
        Args:
            tool_calls: List of tool call dictionaries
            
        Returns:
            SHA-256 hash of the tool calls
        """
        # Normalize tool calls for consistent hashing
        normalized = []
        for call in tool_calls:
            if isinstance(call, dict):
                # Sort keys for consistent ordering
                normalized_call = {}
                for key in sorted(call.keys()):
                    value = call[key]
                    if isinstance(value, (dict, list)):
                        # Recursively normalize nested structures
                        normalized_call[key] = json.dumps(value, sort_keys=True)
                    else:
                        normalized_call[key] = str(value)
                normalized.append(normalized_call)
        
        # Create deterministic string representation
        tool_calls_str = json.dumps(normalized, sort_keys=True)
        
        # Generate hash
        return hashlib.sha256(tool_calls_str.encode()).hexdigest()
    
    def generate_reasoning_hash(self, reasoning_text: str) -> str:
        """
        Generate hash for reasoning text.
        
        Args:
            reasoning_text: The model's reasoning/thought process text
            
        Returns:
            SHA-256 hash of the reasoning text
        """
        normalized_text = reasoning_text.strip()
        return hashlib.sha256(normalized_text.encode()).hexdigest()
    
    def create_signature(
        self,
        tool_calls: list,
        reasoning_text: Optional[str] = None,
        timestamp: Optional[float] = None
    ) -> ThoughtSignature:
        """
        Create a complete thought signature.
        
        Args:
            tool_calls: List of tool call dictionaries
            reasoning_text: Optional reasoning text from the model
            timestamp: Optional timestamp (defaults to current time)
            
        Returns:
            ThoughtSignature object
        """
        if timestamp is None:
            timestamp = time.time()
        
        # Generate hashes
        tool_calls_hash = self.generate_tool_calls_hash(tool_calls)
        reasoning_hash = None
        if reasoning_text:
            reasoning_hash = self.generate_reasoning_hash(reasoning_text)
        
        # Create combined hash for final signature
        combined_data = f"{self.model}|{timestamp}|{tool_calls_hash}"
        if reasoning_hash:
            combined_data += f"|{reasoning_hash}"
        combined_data += f"|{self._secret_salt}"
        
        final_signature = hashlib.sha256(combined_data.encode()).hexdigest()
        
        return ThoughtSignature(
            model=self.model,
            timestamp=timestamp,
            tool_calls_hash=tool_calls_hash,
            reasoning_hash=reasoning_hash,
            signature=final_signature
        )
    
    def validate_signature(
        self,
        signature_obj: ThoughtSignature,
        tool_calls: list,
        reasoning_text: Optional[str] = None,
        tolerance_seconds: int = 300
    ) -> bool:
        """
        Validate a thought signature.
        
        Args:
            signature_obj: The ThoughtSignature to validate
            tool_calls: Original tool calls to verify against
            reasoning_text: Original reasoning text to verify against
            tolerance_seconds: Time tolerance in seconds (default: 5 minutes)
            
        Returns:
            True if signature is valid, False otherwise
        """
        # Check timestamp freshness
        current_time = time.time()
        if abs(current_time - signature_obj.timestamp) > tolerance_seconds:
            return False
        
        # Verify tool calls hash
        expected_tool_hash = self.generate_tool_calls_hash(tool_calls)
        if expected_tool_hash != signature_obj.tool_calls_hash:
            return False
        
        # Verify reasoning hash if present
        if signature_obj.reasoning_hash:
            if not reasoning_text:
                return False
            expected_reasoning_hash = self.generate_reasoning_hash(reasoning_text)
            if expected_reasoning_hash != signature_obj.reasoning_hash:
                return False
        
        # Recreate signature to verify
        expected_signature = self.create_signature(
            tool_calls=tool_calls,
            reasoning_text=reasoning_text,
            timestamp=signature_obj.timestamp
        )
        
        return expected_signature.signature == signature_obj.signature


class GeminiToolProcessor:
    """
    Main processor for Gemini 3.0 Pro tool calls with thought signature support.
    """
    
    def __init__(self, model: str = "gemini-3.0-pro"):
        """
        Initialize the Gemini tool processor.
        
        Args:
            model: Gemini model name
        """
        self.model = model
        self.signature_generator = ThoughtSignatureGenerator(model)
    
    def process_with_signature(
        self,
        gemini_response: Dict[str, Any],
        include_reasoning: bool = True
    ) -> Dict[str, Any]:
        """
        Process Gemini response and add thought signature.
        
        Args:
            gemini_response: Raw response from Gemini API
            include_reasoning: Whether to include reasoning in signature
            
        Returns:
            Processed response with thought signature
        """
        # Extract tool calls from Gemini response
        tool_calls = self._extract_tool_calls(gemini_response)
        
        # Extract reasoning if available and requested
        reasoning_text = None
        if include_reasoning:
            reasoning_text = self._extract_reasoning(gemini_response)
        
        # Generate thought signature
        signature = self.signature_generator.create_signature(
            tool_calls=tool_calls,
            reasoning_text=reasoning_text
        )
        
        # Return enhanced response
        return {
            "original_response": gemini_response,
            "tool_calls": tool_calls,
            "reasoning": reasoning_text,
            "thought_signature": signature.to_dict(),
            "metadata": {
                "model": self.model,
                "processed_at": time.time(),
                "signature_valid": True
            }
        }
    
    def validate_processed_response(
        self,
        processed_response: Dict[str, Any]
    ) -> bool:
        """
        Validate a previously processed response.
        
        Args:
            processed_response: Response processed by process_with_signature
            
        Returns:
            True if signature is valid, False otherwise
        """
        if "thought_signature" not in processed_response:
            return False
        
        if "tool_calls" not in processed_response:
            return False
        
        # Reconstruct signature object
        signature_data = processed_response["thought_signature"]
        signature_obj = ThoughtSignature.from_dict(signature_data)
        
        # Get original data
        tool_calls = processed_response["tool_calls"]
        reasoning_text = processed_response.get("reasoning")
        
        # Validate
        return self.signature_generator.validate_signature(
            signature_obj=signature_obj,
            tool_calls=tool_calls,
            reasoning_text=reasoning_text
        )
    
    def _extract_tool_calls(self, gemini_response: Dict[str, Any]) -> list:
        """
        Extract tool calls from Gemini response.
        
        Args:
            gemini_response: Raw Gemini API response
            
        Returns:
            List of tool call dictionaries
        """
        # This is a simplified extraction - adjust based on actual Gemini API response format
        tool_calls = []
        
        # Check for function calling format
        if "candidates" in gemini_response:
            for candidate in gemini_response["candidates"]:
                if "content" in candidate and "parts" in candidate["content"]:
                    for part in candidate["content"]["parts"]:
                        if "functionCall" in part:
                            tool_calls.append({
                                "function": part["functionCall"]["name"],
                                "args": part["functionCall"].get("args", {})
                            })
        
        return tool_calls
    
    def _extract_reasoning(self, gemini_response: Dict[str, Any]) -> Optional[str]:
        """
        Extract reasoning text from Gemini response.
        
        Args:
            gemini_response: Raw Gemini API response
            
        Returns:
            Reasoning text or None if not available
        """
        # This is a simplified extraction - adjust based on actual Gemini API response format
        reasoning_parts = []
        
        if "candidates" in gemini_response:
            for candidate in gemini_response["candidates"]:
                if "content" in candidate and "parts" in candidate["content"]:
                    for part in candidate["content"]["parts"]:
                        if isinstance(part, dict) and "text" in part:
                            text = part["text"]
                            # Simple heuristic: look for reasoning indicators
                            if any(indicator in text.lower() for indicator in 
                                   ["reasoning:", "thought:", "thinking:", "step"]):
                                reasoning_parts.append(text)
        
        return " ".join(reasoning_parts) if reasoning_parts else None
```

### –ë–ª–æ–∫ 2

**–§–∞–π–ª:** `app/agents/__init__.py`

```python
"""
Agents package for AI tool processing with thought signatures.
"""

from app.agents.thought_signature import (
    ThoughtSignature,
    ThoughtSignatureGenerator,
    GeminiToolProcessor
)

__all__ = [
    "ThoughtSignature",
    "ThoughtSignatureGenerator",
    "GeminiToolProcessor"
]
```

---

## üìñ –ü–æ—è—Å–Ω–µ–Ω–∏—è –∫ –∫–æ–¥—É

```
# filepath: tests/test_thought_signature.py
"""
Tests for Thought Signature functionality.
"""

import pytest
import time
from app.agents.thought_signature import (
    ThoughtSignature,
    ThoughtSignatureGenerator,
    GeminiToolProcessor
)


class TestThoughtSignature:
    """Test ThoughtSignature dataclass."""
    
    def test_creation(self):
        """Test creating a ThoughtSignature."""
        signature = ThoughtSignature(
            model="gemini-3.0-pro",
            timestamp=1234567890.0,
            tool_calls_hash="abc123",
            reasoning_hash="def456",
            signature="final_sig"
        )
        
        assert signature.model == "gemini-3.0-pro"
        assert signature.timestamp == 1234567890.0
        assert signature.tool_calls_hash == "abc123"
        assert signature.reasoning_hash == "def456"
        assert signature.signature == "final_sig"
    
    def test_to_from_dict(self):
        """Test dictionary serialization/deserialization."""
        original = ThoughtSignature(
            model="gemini-3.0-pro",
            timestamp=1234567890.0,
            tool_calls_hash="abc123",
            reasoning_hash="def456",
            signature="final_sig"
        )
        
        as_dict = original.to_dict()
        restored = ThoughtSignature.from_dict(as_dict)
        
        assert original == restored


class TestThoughtSignatureGenerator:
    """Test ThoughtSignatureGenerator."""
    
    def setup_method(self):
        """Setup test fixture."""
        self.generator = ThoughtSignatureGenerator(model="gemini-3.0-pro")
    
    def test_generate_tool_calls_hash(self):
        """Test tool calls hash generation."""
        tool_calls = [
            {"function": "search", "args": {"query": "test"}},
            {"function": "calculate", "args": {"x": 1, "y": 2}}
        ]
        
        hash1 = self.generator.generate_tool_calls_hash(tool_calls)
        hash2 = self.generator.generate_tool_calls_hash(tool_calls)
        
        # Same input should produce same hash
        assert hash1 == hash2
        
        # Different input should produce different hash
        different_calls = [{"function": "search", "args": {"query": "different"}}]
        hash3 = self.generator.generate_tool_calls_hash(different_calls)
        assert hash1 != hash3
    
    def test_generate_reasoning_hash(self):
        """Test reasoning hash generation."""
        reasoning = "I need to search for information about AI."
        
        hash1 = self.generator.generate_reasoning_hash(reasoning)
        hash2 = self.generator.generate_reasoning_hash(reasoning)
        
        assert hash1 == hash2
        
        # Different reasoning should produce different hash
        different_reasoning = "Different reasoning text."
        hash3 = self.generator.generate_reasoning_hash(different_reasoning)
        assert hash1 != hash3
    
    def test_create_signature(self):
        """Test complete signature creation."""
        tool_calls = [{"function": "search", "args": {"query": "test"}}]
        reasoning = "Test reasoning"
        
        signature = self.generator.create_signature(
            tool_calls=tool_calls,
            reasoning_text=reasoning
        )
        
        assert signature.model == "gemini-3.0-pro"
        assert signature.timestamp <= time.time()
        assert signature.tool_calls_hash is not None
        assert signature.reasoning_hash is not None
        assert signature.signature is not None
    
    def test_validate_signature(self):
        """Test signature validation."""
        tool_calls = [{"function": "search", "args": {"query": "test"}}]
        reasoning = "Test reasoning"
        
        signature = self.generator.create_signature(
            tool_calls=tool_calls,
            reasoning_text=reasoning
        )
        
        # Valid signature should pass
        assert self.generator.validate_signature(
            signature_obj=signature,
            tool_calls=tool_calls,
            reasoning_text=reasoning
        )
        
        # Different tool calls should fail
        different_calls = [{"function": "search", "args": {"query": "different"}}]
        assert not self.generator.validate_signature(
            signature_obj=signature,
            tool_calls=different_calls,
            reasoning_text=reasoning
        )
        
        # Different reasoning should fail
        different_reasoning = "Different reasoning"
        assert not self.generator.validate_signature(
            signature_obj=signature,
            tool_calls=tool_calls,
            reasoning_text=different_reasoning
        )
    
    def test_validate_signature_timestamp(self):
        """Test timestamp validation with tolerance."""
        tool_calls = [{"function": "search", "args": {"query": "test"}}]
        
        # Create signature with old timestamp
        old_timestamp = time.time() - 400  # More than 5 minutes old
        signature = self.generator.create_signature(
            tool_calls=tool_calls,
            reasoning_text=None,
            timestamp=old_timestamp
        )
        
        # Should fail with default tolerance (300 seconds)
        assert not self.generator.validate_signature(
            signature_obj=signature,
            tool_calls=tool_calls,
            reasoning_text=None
        )
        
        # Should pass with larger tolerance
        assert self.generator.validate_signature(
            signature_obj=signature,
            tool_calls=tool_calls,
            reasoning_text=None,
            tolerance_seconds=500
        )


class TestGeminiToolProcessor:
    """Test GeminiToolProcessor."""
    
    def setup_method(self):
        """Setup test fixture."""
        self.processor = GeminiToolProcessor(model="gemini-3.0-pro")
    
    def test_process_with_signature(self):
        """Test processing Gemini response with signature."""
        # Mock Gemini response
        gemini_response = {
            "candidates": [{
                "content": {
                    "parts": [
                        {"text": "Reasoning: I need to search for AI information."},
                        {"functionCall": {
                            "name": "search",
                            "args": {"query": "artificial intelligence"}
                        }}
                    ]
                }
            }]
        }
        
        processed = self.processor.process_with_signature(
            gemini_response=gemini_response,
            include_reasoning=True
        )
        
        assert "original_response" in processed
        assert "tool_calls" in processed
        assert "reasoning" in processed
        assert "thought_signature" in processed
        assert "metadata" in processed
        
        # Should have extracted tool calls
        assert len(processed["tool_calls"]) > 0
        
        # Should have extracted reasoning
        assert processed["reasoning"] is not None
        
        # Signature should be valid
        assert processed["metadata"]["signature_valid"] is True
    
    def test_validate_processed_response(self):
        """Test validation of processed response."""
        # Create a processed response
        gemini_response = {
            "candidates": [{
                "content": {
                    "parts": [
                        {"functionCall": {
                            "name": "calculate",
                            "args": {"x": 5, "y": 3}
                        }}
                    ]
                }
            }]
        }
        
        processed = self.processor.process_with_signature(
            gemini_response=gemini_response,
            include_reasoning=False
        )
        
        # Should validate successfully
        assert self.processor.validate_processed_response(processed)
        
        # Tampered response should fail
        tampered = processed.copy()
        tampered["tool_calls"][0]["args"]["x"] = 10  # Change argument
        
        assert not self.processor.validate_processed_response(tampered)
    
    def test_extract_tool_calls(self):
        """Test tool call extraction."""

---

## üõ†Ô∏è –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤

1. ‚úÖ **read_file**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=config/settings.py, include_line_numbers=True`

2. ‚úÖ **read_code_chunk**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=app/llm/api_client.py, chunk_name=LLMClient`

3. ‚úÖ **web_search**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `query=Gemini 3.0 Pro API reasoning output thought signatures, max_results=10, region=wt-wt`

4. ‚úÖ **read_code_chunk**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=app/agents/orchestrator.py, chunk_name=orchestrate`

5. ‚úÖ **read_code_chunk**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=app/llm/api_client.py, chunk_name=call_llm_with_tools`

6. ‚úÖ **web_search**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `query=Gemini 3.0 Pro thought signature API response example, max_results=10, region=wt-wt`

7. ‚úÖ **read_code_chunk**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=app/tools/tool_executor.py, chunk_name=parse_tool_call`

8. ‚úÖ **search_code**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `query=parse_tool_call, search_type=function`

9. ‚úÖ **read_code_chunk**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=app/llm/api_client.py, chunk_name=_parse_response`

10. ‚úÖ **read_file**
   - –ê—Ä–≥—É–º–µ–Ω—Ç—ã: `file_path=app/llm/api_client.py, include_line_numbers=True`

---

*–û—Ç—á–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏: 2025-12-21T02:00:33.865944*