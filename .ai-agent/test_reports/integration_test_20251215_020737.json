{
  "metadata": {
    "timestamp": "2025-12-15T02:07:37.577693",
    "project_dir": "C:\\Users\\Admin\\AI_Assistant_Pro",
    "user_query": "Я проверяю создание истории беседы с помощью тестового скрипта, и при проверке мне постоянно выходит ошибка, можешь выяснить проблема с тестовым скриптом или файлами, которые создаюь историю беседы (то есть с файлами, которые скрипт тестирует). Если есть проблема, напиши полный код ее решения. Traceback (most recent call last):  File \"c:\\Users\\Admin\\AI_Assistant_Pro\\scripts\\test_history_manager.py\", line 167, in test_create_history    thread = manager.create_thread(             ^^^^^^^^^^^^^^^^^^^^^AttributeError: 'HistoryManager' object has no attribute 'create_thread'",
    "duration_seconds": 143.92062854766846,
    "models_used": {
      "orchestrator": "Claude Sonnet 4.5 (RouterAI)",
      "code_generator": "deepseek-chat"
    }
  },
  "orchestrator": {
    "analysis": "Проблема найдена! В классе `HistoryManager` (файл `app/history/manager.py`) **отсутствует метод `create_thread`**, но **есть метод `create_new_thread`** (строка 228-248).\n\nТестовый скрипт вызывает `manager.create_thread()` (строка 167), но такого метода нет в классе. Это несоответствие имен методов.\n\nЕсть два варианта решения:\n1. **Переименовать метод** в `HistoryManager` с `create_new_thread` → `create_thread`\n2. **Исправить вызов** в тестовом скрипте с `create_thread` → `create_new_thread`\n\nТакже обнаружена **дублированная декларация метода `get_thread`** в `HistoryManager`:\n- Первый раз на строках 63-78\n- Второй раз на строках 250-267\n\nРекомендую **вариант 1** (переименовать метод в HistoryManager), так как имя `create_thread` более короткое и согласуется с методом `get_thread`. Также нужно удалить дублирующийся метод `get_thread`.",
    "instruction": "**Task:** Fix AttributeError by renaming method and removing duplicate method in HistoryManager\n\n**File:** `app/history/manager.py`\n\n**Location:** HistoryManager class\n\n**Changes:**\n\n1. **Rename method `create_new_thread` to `create_thread`** (around line 228):\n   - Change method definition from `def create_new_thread(` to `def create_thread(`\n   - Keep all parameters and logic unchanged: `user_id: str, project_path: Optional[str] = None, title: str = \"Новый диалог\"`\n   - Keep the docstring and implementation exactly as is\n\n2. **Remove duplicate `get_thread` method** (lines 250-267):\n   - Delete the entire second declaration of `get_thread` method\n   - Keep only the first declaration (lines 63-78)\n   - The first declaration already has the correct implementation\n\n**Why:** \n- The test script calls `manager.create_thread()` but the method is named `create_new_thread()`, causing AttributeError\n- Having two identical `get_thread` methods is redundant and violates DRY principle\n- Shorter method name `create_thread` is more consistent with `get_thread` naming pattern\n\n**Complete corrected code for HistoryManager class:**\n\n```python\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    def list_user_threads(self, user_id: str, limit: int = 20) -> List[Thread]:\n        \"\"\"\n        Получает список диалогов пользователя.\n\n        Args:\n            user_id: ID пользователя\n            limit: Максимальное количество возвращаемых диалогов (по умолчанию 20)\n\n        Returns:\n            Список объектов Thread\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}, limit={limit}\")\n        try:\n            threads = self.storage.list_user_threads(user_id, limit=limit)\n            logger.debug(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            return []\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает диалог по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread: thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread_id}\")\n                return thread\n            else:\n                logger.warning(f\"Thread not found: {thread_id}\")\n                return None\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise\n\n    def get_thread_stats(self, thread_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Получает статистику диалога по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Словарь со статистикой диалога или пустой словарь, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread stats for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                return {\n                    \"id\": thread.id,\n                    \"title\": thread.title,\n                    \"message_count\": thread.message_count,\n                    \"total_tokens\": thread.total_tokens,\n                    \"created_at\": thread.created_at,\n                    \"updated_at\": thread.updated_at\n                }\n            else:\n                logger.warning(f\"Thread not found for stats: thread_id={thread_id}\")\n                return {}\n        except Exception as e:\n            logger.error(f\"Failed to get thread stats: {e}\", exc_info=True)\n            return {}\n    \n    \n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise\n```"
  },
  "code_generator": {
    "code_blocks": [
      {
        "filepath": "app/history/manager.py",
        "language": "python",
        "code": "import logging\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import asdict\nfrom app.history.storage import HistoryStorage, Message, Thread\nfrom app.history.compressor import compress_history_if_needed, prune_irrelevant_context\nfrom config.settings import cfg\n\nlogger = logging.getLogger(__name__)\n\n\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    def list_user_threads(self, user_id: str, limit: int = 20) -> List[Thread]:\n        \"\"\"\n        Получает список диалогов пользователя.\n\n        Args:\n            user_id: ID пользователя\n            limit: Максимальное количество возвращаемых диалогов (по умолчанию 20)\n\n        Returns:\n            Список объектов Thread\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}, limit={limit}\")\n        try:\n            threads = self.storage.list_user_threads(user_id, limit=limit)\n            logger.debug(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            return []\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает диалог по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread: thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread_id}\")\n                return thread\n            else:\n                logger.warning(f\"Thread not found: {thread_id}\")\n                return None\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise\n\n    def get_thread_stats(self, thread_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Получает статистику диалога по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Словарь со статистикой диалога или пустой словарь, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread stats for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                return {\n                    \"id\": thread.id,\n                    \"title\": thread.title,\n                    \"message_count\": thread.message_count,\n                    \"total_tokens\": thread.total_tokens,\n                    \"created_at\": thread.created_at,\n                    \"updated_at\": thread.updated_at\n                }\n            else:\n                logger.warning(f\"Thread not found for stats: thread_id={thread_id}\")\n                return {}\n        except Exception as e:\n            logger.error(f\"Failed to get thread stats: {e}\", exc_info=True)\n            return {}\n    \n    \n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise",
        "context": "HistoryManager class"
      }
    ],
    "explanation": "Этот код исправляет две проблемы в классе `HistoryManager`:\n\n1. **Переименование метода `create_new_thread` в `create_thread`**:\n   - Метод `create_new_thread` (строки 228-245 в оригинальном коде) был переименован в `create_thread`\n   - Все параметры (`user_id`, `project_path`, `title`), логика и документация остались без изменений\n   - Это исправляет `AttributeError`, который возникал, когда тестовый скрипт вызывал `manager.create_thread()`, а метод имел другое имя\n\n2. **Удаление дублирующего метода `get_thread`**:\n   - В оригинальном коде было два одинаковых метода `get_thread`:\n     - Первый (строки 63-78) с правильной реализацией\n     - Второй (строки 250-267) с идентичной функциональностью\n   - Удален второй метод, чтобы избежать нарушения принципа DRY (Don't Repeat Yourself)\n   - Оставлен только первый метод, который уже содержит корректную реализацию\n\n**Результат исправлений**:\n- Теперь код соответствует ожиданиям тестового скрипта\n- Устранена избыточность в коде\n- Имена методов стали более согласованными (`create_thread` и `get_thread` следуют одной схеме именования)\n- Все импорты и остальная функциональность класса сохранены без изменений",
    "frontend_json": {
      "success": true,
      "code_blocks": [
        {
          "code": "import logging\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import asdict\nfrom app.history.storage import HistoryStorage, Message, Thread\nfrom app.history.compressor import compress_history_if_needed, prune_irrelevant_context\nfrom config.settings import cfg\n\nlogger = logging.getLogger(__name__)\n\n\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    def list_user_threads(self, user_id: str, limit: int = 20) -> List[Thread]:\n        \"\"\"\n        Получает список диалогов пользователя.\n\n        Args:\n            user_id: ID пользователя\n            limit: Максимальное количество возвращаемых диалогов (по умолчанию 20)\n\n        Returns:\n            Список объектов Thread\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}, limit={limit}\")\n        try:\n            threads = self.storage.list_user_threads(user_id, limit=limit)\n            logger.debug(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            return []\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает диалог по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread: thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread_id}\")\n                return thread\n            else:\n                logger.warning(f\"Thread not found: {thread_id}\")\n                return None\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise\n\n    def get_thread_stats(self, thread_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Получает статистику диалога по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Словарь со статистикой диалога или пустой словарь, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread stats for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                return {\n                    \"id\": thread.id,\n                    \"title\": thread.title,\n                    \"message_count\": thread.message_count,\n                    \"total_tokens\": thread.total_tokens,\n                    \"created_at\": thread.created_at,\n                    \"updated_at\": thread.updated_at\n                }\n            else:\n                logger.warning(f\"Thread not found for stats: thread_id={thread_id}\")\n                return {}\n        except Exception as e:\n            logger.error(f\"Failed to get thread stats: {e}\", exc_info=True)\n            return {}\n    \n    \n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise",
          "filepath": "app/history/manager.py",
          "language": "python",
          "context": "HistoryManager class"
        }
      ],
      "combined_code": "\n\n# ==================================================# filepath: app/history/manager.py\n# context: HistoryManager class\n\nimport logging\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import asdict\nfrom app.history.storage import HistoryStorage, Message, Thread\nfrom app.history.compressor import compress_history_if_needed, prune_irrelevant_context\nfrom config.settings import cfg\n\nlogger = logging.getLogger(__name__)\n\n\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    def list_user_threads(self, user_id: str, limit: int = 20) -> List[Thread]:\n        \"\"\"\n        Получает список диалогов пользователя.\n\n        Args:\n            user_id: ID пользователя\n            limit: Максимальное количество возвращаемых диалогов (по умолчанию 20)\n\n        Returns:\n            Список объектов Thread\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}, limit={limit}\")\n        try:\n            threads = self.storage.list_user_threads(user_id, limit=limit)\n            logger.debug(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            return []\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает диалог по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread: thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread_id}\")\n                return thread\n            else:\n                logger.warning(f\"Thread not found: {thread_id}\")\n                return None\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise\n\n    def get_thread_stats(self, thread_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Получает статистику диалога по ID.\n\n        Args:\n            thread_id: ID диалога\n\n        Returns:\n            Словарь со статистикой диалога или пустой словарь, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread stats for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                return {\n                    \"id\": thread.id,\n                    \"title\": thread.title,\n                    \"message_count\": thread.message_count,\n                    \"total_tokens\": thread.total_tokens,\n                    \"created_at\": thread.created_at,\n                    \"updated_at\": thread.updated_at\n                }\n            else:\n                logger.warning(f\"Thread not found for stats: thread_id={thread_id}\")\n                return {}\n        except Exception as e:\n            logger.error(f\"Failed to get thread stats: {e}\", exc_info=True)\n            return {}\n    \n    \n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise",
      "explanation": "Этот код исправляет две проблемы в классе `HistoryManager`:\n\n1. **Переименование метода `create_new_thread` в `create_thread`**:\n   - Метод `create_new_thread` (строки 228-245 в оригинальном коде) был переименован в `create_thread`\n   - Все параметры (`user_id`, `project_path`, `title`), логика и документация остались без изменений\n   - Это исправляет `AttributeError`, который возникал, когда тестовый скрипт вызывал `manager.create_thread()`, а метод имел другое имя\n\n2. **Удаление дублирующего метода `get_thread`**:\n   - В оригинальном коде было два одинаковых метода `get_thread`:\n     - Первый (строки 63-78) с правильной реализацией\n     - Второй (строки 250-267) с идентичной функциональностью\n   - Удален второй метод, чтобы избежать нарушения принципа DRY (Don't Repeat Yourself)\n   - Оставлен только первый метод, который уже содержит корректную реализацию\n\n**Результат исправлений**:\n- Теперь код соответствует ожиданиям тестового скрипта\n- Устранена избыточность в коде\n- Имена методов стали более согласованными (`create_thread` и `get_thread` следуют одной схеме именования)\n- Все импорты и остальная функциональность класса сохранены без изменений",
      "error": null,
      "model_used": "deepseek-chat",
      "tokens_used": 0
    }
  }
}