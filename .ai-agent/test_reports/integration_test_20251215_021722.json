{
  "metadata": {
    "timestamp": "2025-12-15T02:17:22.165273",
    "project_dir": "C:\\Users\\Admin\\AI_Assistant_Pro",
    "user_query": "Можешь проанализировать все файлы занимающийся созданием истории бесед, потом тестового скрипта и узнать, почему выходит ошибка  [2025-12-15 02:12:35] [INFO] Pruned 2 tokens from irrelevant tool outputs[2025-12-15 02:12:35] [INFO] After pruning: 6 messages[2025-12-15 02:12:35] [INFO] Removed 0 irrelevant messages[2025-12-15 02:12:35] [ERROR] Assertion failed: Irrelevant tool results should be removed[2025-12-15 02:12:35] [INFO] Starting cleanup[2025-12-15 02:12:35] [INFO] Cleaning up test database...[2025-12-15 02:12:35] [INFO] Test database does not exist, nothing to clean up , это проблема тестового скрипта или кода создающего историю беседы. После напиши код, который исправляет ошибку",
    "duration_seconds": 118.80048441886902,
    "models_used": {
      "orchestrator": "Claude Opus 4.5 (RouterAI)",
      "code_generator": "deepseek-chat"
    }
  },
  "orchestrator": {
    "analysis": "",
    "instruction": "**Task:** Исправить тест `test_prune_context()` в тестовом скрипте, чтобы он правильно проверял поведение функции `prune_irrelevant_context()` — функция заменяет контент нерелевантных сообщений на `[PRUNED: ...]`, а не удаляет их.\n\n**File:** `scripts/test_history_manager.py`\n\n**Location:** Функция `test_prune_context()`, строки 305-362\n\n**Changes:**\n\n1. **Строки 333-335**: Изменить логику подсчёта. Вместо подсчёта удалённых сообщений, нужно считать сообщения с заменённым контентом (начинающимся с `[PRUNED`):\n   - Заменить:\n     ```python\n     pruned_count = len(pruned_messages)\n     logger.info(f\"After pruning: {pruned_count} messages\")\n     logger.info(f\"Removed {original_count - pruned_count} irrelevant messages\")\n     ```\n   - На:\n     ```python\n     pruned_count = len(pruned_messages)\n     pruned_tool_count = sum(1 for m in pruned_messages if m.content.startswith(\"[PRUNED\"))\n     logger.info(f\"After pruning: {pruned_count} messages\")\n     logger.info(f\"Pruned {pruned_tool_count} tool messages (content replaced)\")\n     ```\n\n2. **Строки 341-345**: Полностью переписать проверку. Вместо проверки на удаление, проверять что:\n   - Релевантные tool-сообщения (с `auth.py`) сохранили оригинальный контент\n   - Нерелевантные tool-сообщения (с `logger.py`, `user.py`) имеют контент, начинающийся с `[PRUNED`\n   \n   Заменить:\n   ```python\n   # Check that only auth.py tool result remains\n   auth_tools = [m for m in tool_messages_after if \"auth.py\" in m.content]\n   other_tools = [m for m in tool_messages_after if \"auth.py\" not in m.content]\n\n   assert len(other_tools) == 0, \"Irrelevant tool results should be removed\"\n   assert len(auth_tools) > 0, \"Relevant tool results should remain\"\n   ```\n   \n   На:\n   ```python\n   # Check that relevant tool results (auth.py) kept original content\n   auth_tools = [m for m in tool_messages_after if \"auth.py\" in m.content and not m.content.startswith(\"[PRUNED\")]\n   \n   # Check that irrelevant tool results were pruned (content replaced with [PRUNED...])\n   pruned_tools = [m for m in tool_messages_after if m.content.startswith(\"[PRUNED\")]\n   \n   # Verify: auth.py tool should remain with original content\n   assert len(auth_tools) == 1, f\"Relevant tool result (auth.py) should remain unchanged, got {len(auth_tools)}\"\n   \n   # Verify: other tools (logger.py, user.py) should be pruned\n   assert len(pruned_tools) == 2, f\"Irrelevant tool results should be pruned, got {len(pruned_tools)}\"\n   ```\n\n3. **Строки 350-355**: Обновить возвращаемый словарь, чтобы отражать правильную метрику:\n   - Заменить:\n     ```python\n     return {\n         \"original_count\": original_count,\n         \"pruned_count\": pruned_count,\n         \"removed_count\": original_count - pruned_count,\n         \"files_mentioned\": [\"app/services/auth.py\"]\n     }\n     ```\n   - На:\n     ```python\n     return {\n         \"original_count\": original_count,\n         \"final_count\": pruned_count,\n         \"pruned_tool_count\": len(pruned_tools),\n         \"relevant_tools_kept\": len(auth_tools),\n         \"files_mentioned\": [\"app/services/auth.py\"]\n     }\n     ```\n\n4. **Строка 440**: В функции `main()` обновить проверку результата теста:\n   - Заменить:\n     ```python\n     test_results[\"prune_context\"] = prune_stats.get(\"removed_count\", 0) > 0\n     ```\n   - На:\n     ```python\n     test_results[\"prune_context\"] = prune_stats.get(\"pruned_tool_count\", 0) > 0\n     ```\n\n**Why:** Тест неправильно интерпретировал поведение функции `prune_irrelevant_context()`. Функция не удаляет сообщения из истории, а заменяет их контент на краткую метку `[PRUNED: ...]`, что экономит токены, сохраняя структуру диалога. Исправление теста приводит его в соответствие с реальным поведением функции."
  },
  "code_generator": {
    "code_blocks": [
      {
        "filepath": "scripts/test_history_manager.py",
        "language": "python",
        "code": "def test_prune_context() -> Dict[str, Any]:\n    \"\"\"Test context pruning for irrelevant tool results.\"\"\"\n    logger = logging.getLogger(__name__)\n    logger.info(\"Testing context pruning for irrelevant tool results...\")\n\n    try:\n        # Create test messages with tool results\n        messages = [\n            Message(id=\"1\", thread_id=\"test\", role=\"user\", content=\"Show me the auth service code\", tokens=0),\n            Message(id=\"2\", thread_id=\"test\", role=\"tool\", content=\"File: app/services/auth.py\\nCode: def authenticate(): ...\", tokens=0),\n            Message(id=\"3\", thread_id=\"test\", role=\"tool\", content=\"File: app/utils/logger.py\\nCode: def log(): ...\", tokens=0),\n            Message(id=\"4\", thread_id=\"test\", role=\"tool\", content=\"File: app/models/user.py\\nCode: class User: ...\", tokens=0),\n            Message(id=\"5\", thread_id=\"test\", role=\"assistant\", content=\"Here's the auth service code...\", tokens=0),\n            Message(id=\"6\", thread_id=\"test\", role=\"user\", content=\"Now modify only app/services/auth.py\", tokens=0),\n        ]\n\n        original_count = len(messages)\n        logger.info(f\"Original messages: {original_count}\")\n\n        # User query mentioning specific file\n        user_query = \"Modify the authenticate function in app/services/auth.py\"\n\n        # Apply pruning directly using the function\n        pruned_messages = prune_irrelevant_context(\n            history=messages,\n            current_query=user_query\n        )\n\n        pruned_count = len(pruned_messages)\n        pruned_tool_count = sum(1 for m in pruned_messages if m.content.startswith(\"[PRUNED\"))\n        logger.info(f\"After pruning: {pruned_count} messages\")\n        logger.info(f\"Pruned {pruned_tool_count} tool messages (content replaced)\")\n\n        # Verify irrelevant tool results were removed\n        tool_messages_before = [m for m in messages if m.role == \"tool\"]\n        tool_messages_after = [m for m in pruned_messages if m.role == \"tool\"]\n\n        # Check that relevant tool results (auth.py) kept original content\n        auth_tools = [m for m in tool_messages_after if \"auth.py\" in m.content and not m.content.startswith(\"[PRUNED\")]\n        \n        # Check that irrelevant tool results were pruned (content replaced with [PRUNED...])\n        pruned_tools = [m for m in tool_messages_after if m.content.startswith(\"[PRUNED\")]\n        \n        # Verify: auth.py tool should remain with original content\n        assert len(auth_tools) == 1, f\"Relevant tool result (auth.py) should remain unchanged, got {len(auth_tools)}\"\n        \n        # Verify: other tools (logger.py, user.py) should be pruned\n        assert len(pruned_tools) == 2, f\"Irrelevant tool results should be pruned, got {len(pruned_tools)}\"\n\n        logger.success(\"Context pruning test passed successfully\")\n\n        return {\n            \"original_count\": original_count,\n            \"final_count\": pruned_count,\n            \"pruned_tool_count\": len(pruned_tools),\n            \"relevant_tools_kept\": len(auth_tools),\n            \"files_mentioned\": [\"app/services/auth.py\"]\n        }\n\n    except AssertionError as e:\n        logger.error(f\"Assertion failed: {e}\")\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error in pruning test: {e}\")\n        raise",
        "context": "test_prune_context function"
      },
      {
        "filepath": "scripts/test_history_manager.py",
        "language": "python",
        "code": "async def main() -> int:\n    \"\"\"Main test runner.\"\"\"\n    print(\"\\n\" + \"=\" * 40)\n    print(\"=== HISTORY MANAGEMENT TEST SUITE ===\")\n    print(\"=\" * 40 + \"\\n\")\n\n    # Setup logging\n    setup_logging()\n    logger = logging.getLogger(__name__)\n\n    # Test results tracker\n    test_results = {}\n\n    try:\n        # Test 1: Imports\n        logger.info(\"Starting test: Imports\")\n        test_results[\"imports\"] = test_imports()\n\n        if not test_results[\"imports\"]:\n            logger.error(\"Import test failed. Skipping further tests.\")\n            return 1\n\n        # Test 2: API Connection\n        logger.info(\"Starting test: API Connection\")\n        test_results[\"api_connection\"] = await test_api_connection()\n\n        if not test_results[\"api_connection\"]:\n            logger.warning(\"API connection test failed. Some tests may be limited.\")\n\n        # Test 3: Create History\n        logger.info(\"Starting test: Create History\")\n        try:\n            thread_id, manager = test_create_history()\n            test_results[\"create_history\"] = True\n        except Exception:\n            test_results[\"create_history\"] = False\n            thread_id, manager = None, None\n\n        # Test 4: History Compression (if history created successfully)\n        if test_results.get(\"create_history\") and thread_id and manager:\n            logger.info(\"Starting test: History Compression\")\n            try:\n                compression_stats = await test_history_compression(manager, thread_id)\n                test_results[\"history_compression\"] = compression_stats.get(\"compression_happened\", False)\n            except Exception:\n                test_results[\"history_compression\"] = False\n        else:\n            logger.warning(\"Skipping compression test - history creation failed\")\n            test_results[\"history_compression\"] = False\n\n        # Test 5: Prune Context\n        logger.info(\"Starting test: Prune Context\")\n        try:\n            prune_stats = test_prune_context()\n            test_results[\"prune_context\"] = prune_stats.get(\"pruned_tool_count\", 0) > 0\n        except Exception:\n            test_results[\"prune_context\"] = False\n\n        # Cleanup\n        logger.info(\"Starting cleanup\")\n        test_results[\"cleanup\"] = await cleanup_test_database()\n\n    except KeyboardInterrupt:\n        logger.error(\"Test suite interrupted by user\")\n        return 1\n    except Exception as e:\n        logger.exception(f\"Unexpected error in main test runner: {e}\")\n        return 1\n\n    # Print summary\n    print(\"\\n\" + \"=\" * 40)\n    print(\"=== TEST RESULTS ===\")\n    print(\"=\" * 40)\n\n    passed = sum(1 for result in test_results.values() if result is True)\n    total = sum(1 for result in test_results.values() if isinstance(result, bool))\n\n    print(f\"\\nSummary: {passed}/{total} tests passed\")\n\n    for test_name, result in test_results.items():\n        status = \"✓ PASS\" if result else \"✗ FAIL\"\n        color = '\\033[92m' if result else '\\033[91m'\n        reset = '\\033[0m'\n        print(f\"  {color}{status}{reset}: {test_name}\")\n\n    print(\"\\n\" + \"=\" * 40)\n\n    # Return exit code\n    if passed == total:\n        logger.success(\"All tests passed!\")\n        return 0\n    else:\n        logger.error(f\"{total - passed} test(s) failed\")\n        return 1",
        "context": "main function"
      }
    ],
    "explanation": "Этот код исправляет тест `test_prune_context()` в соответствии с реальным поведением функции `prune_irrelevant_context()`. Основные изменения:\n\n1. **Обновлён подсчёт сообщений**: Вместо подсчёта удалённых сообщений теперь подсчитываются сообщения с заменённым контентом (начинающимся с `[PRUNED`). Используется генераторное выражение `sum(1 for m in pruned_messages if m.content.startswith(\"[PRUNED\"))`.\n\n2. **Переписана логика проверки**: Теперь тест проверяет, что:\n   - Релевантные tool-сообщения (содержащие `auth.py`) сохранили оригинальный контент\n   - Нерелевантные tool-сообщения (содержащие `logger.py` и `user.py`) имеют контент, начинающийся с `[PRUNED`\n   - Добавлены конкретные проверки: должно остаться 1 неизменённое сообщение с `auth.py` и 2 \"подрезанных\" сообщения\n\n3. **Обновлён возвращаемый словарь**: Вместо `removed_count` теперь возвращаются:\n   - `final_count` - общее количество сообщений после обработки\n   - `pruned_tool_count` - количество tool-сообщений с заменённым контентом\n   - `relevant_tools_kept` - количество релевантных tool-сообщений с оригинальным контентом\n\n4. **Исправлена проверка в main()**: Теперь проверяется `pruned_tool_count > 0` вместо `removed_count > 0`, что корректно отражает поведение функции.\n\n**Важное замечание**: Функция `prune_irrelevant_context()` не удаляет сообщения из истории, а заменяет их контент на краткую метку `[PRUNED: ...]`. Это позволяет экономить токены, сохраняя при этом структуру диалога. Исправленный тест теперь правильно проверяет это поведение.",
    "frontend_json": {
      "success": true,
      "code_blocks": [
        {
          "code": "def test_prune_context() -> Dict[str, Any]:\n    \"\"\"Test context pruning for irrelevant tool results.\"\"\"\n    logger = logging.getLogger(__name__)\n    logger.info(\"Testing context pruning for irrelevant tool results...\")\n\n    try:\n        # Create test messages with tool results\n        messages = [\n            Message(id=\"1\", thread_id=\"test\", role=\"user\", content=\"Show me the auth service code\", tokens=0),\n            Message(id=\"2\", thread_id=\"test\", role=\"tool\", content=\"File: app/services/auth.py\\nCode: def authenticate(): ...\", tokens=0),\n            Message(id=\"3\", thread_id=\"test\", role=\"tool\", content=\"File: app/utils/logger.py\\nCode: def log(): ...\", tokens=0),\n            Message(id=\"4\", thread_id=\"test\", role=\"tool\", content=\"File: app/models/user.py\\nCode: class User: ...\", tokens=0),\n            Message(id=\"5\", thread_id=\"test\", role=\"assistant\", content=\"Here's the auth service code...\", tokens=0),\n            Message(id=\"6\", thread_id=\"test\", role=\"user\", content=\"Now modify only app/services/auth.py\", tokens=0),\n        ]\n\n        original_count = len(messages)\n        logger.info(f\"Original messages: {original_count}\")\n\n        # User query mentioning specific file\n        user_query = \"Modify the authenticate function in app/services/auth.py\"\n\n        # Apply pruning directly using the function\n        pruned_messages = prune_irrelevant_context(\n            history=messages,\n            current_query=user_query\n        )\n\n        pruned_count = len(pruned_messages)\n        pruned_tool_count = sum(1 for m in pruned_messages if m.content.startswith(\"[PRUNED\"))\n        logger.info(f\"After pruning: {pruned_count} messages\")\n        logger.info(f\"Pruned {pruned_tool_count} tool messages (content replaced)\")\n\n        # Verify irrelevant tool results were removed\n        tool_messages_before = [m for m in messages if m.role == \"tool\"]\n        tool_messages_after = [m for m in pruned_messages if m.role == \"tool\"]\n\n        # Check that relevant tool results (auth.py) kept original content\n        auth_tools = [m for m in tool_messages_after if \"auth.py\" in m.content and not m.content.startswith(\"[PRUNED\")]\n        \n        # Check that irrelevant tool results were pruned (content replaced with [PRUNED...])\n        pruned_tools = [m for m in tool_messages_after if m.content.startswith(\"[PRUNED\")]\n        \n        # Verify: auth.py tool should remain with original content\n        assert len(auth_tools) == 1, f\"Relevant tool result (auth.py) should remain unchanged, got {len(auth_tools)}\"\n        \n        # Verify: other tools (logger.py, user.py) should be pruned\n        assert len(pruned_tools) == 2, f\"Irrelevant tool results should be pruned, got {len(pruned_tools)}\"\n\n        logger.success(\"Context pruning test passed successfully\")\n\n        return {\n            \"original_count\": original_count,\n            \"final_count\": pruned_count,\n            \"pruned_tool_count\": len(pruned_tools),\n            \"relevant_tools_kept\": len(auth_tools),\n            \"files_mentioned\": [\"app/services/auth.py\"]\n        }\n\n    except AssertionError as e:\n        logger.error(f\"Assertion failed: {e}\")\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error in pruning test: {e}\")\n        raise",
          "filepath": "scripts/test_history_manager.py",
          "language": "python",
          "context": "test_prune_context function"
        },
        {
          "code": "async def main() -> int:\n    \"\"\"Main test runner.\"\"\"\n    print(\"\\n\" + \"=\" * 40)\n    print(\"=== HISTORY MANAGEMENT TEST SUITE ===\")\n    print(\"=\" * 40 + \"\\n\")\n\n    # Setup logging\n    setup_logging()\n    logger = logging.getLogger(__name__)\n\n    # Test results tracker\n    test_results = {}\n\n    try:\n        # Test 1: Imports\n        logger.info(\"Starting test: Imports\")\n        test_results[\"imports\"] = test_imports()\n\n        if not test_results[\"imports\"]:\n            logger.error(\"Import test failed. Skipping further tests.\")\n            return 1\n\n        # Test 2: API Connection\n        logger.info(\"Starting test: API Connection\")\n        test_results[\"api_connection\"] = await test_api_connection()\n\n        if not test_results[\"api_connection\"]:\n            logger.warning(\"API connection test failed. Some tests may be limited.\")\n\n        # Test 3: Create History\n        logger.info(\"Starting test: Create History\")\n        try:\n            thread_id, manager = test_create_history()\n            test_results[\"create_history\"] = True\n        except Exception:\n            test_results[\"create_history\"] = False\n            thread_id, manager = None, None\n\n        # Test 4: History Compression (if history created successfully)\n        if test_results.get(\"create_history\") and thread_id and manager:\n            logger.info(\"Starting test: History Compression\")\n            try:\n                compression_stats = await test_history_compression(manager, thread_id)\n                test_results[\"history_compression\"] = compression_stats.get(\"compression_happened\", False)\n            except Exception:\n                test_results[\"history_compression\"] = False\n        else:\n            logger.warning(\"Skipping compression test - history creation failed\")\n            test_results[\"history_compression\"] = False\n\n        # Test 5: Prune Context\n        logger.info(\"Starting test: Prune Context\")\n        try:\n            prune_stats = test_prune_context()\n            test_results[\"prune_context\"] = prune_stats.get(\"pruned_tool_count\", 0) > 0\n        except Exception:\n            test_results[\"prune_context\"] = False\n\n        # Cleanup\n        logger.info(\"Starting cleanup\")\n        test_results[\"cleanup\"] = await cleanup_test_database()\n\n    except KeyboardInterrupt:\n        logger.error(\"Test suite interrupted by user\")\n        return 1\n    except Exception as e:\n        logger.exception(f\"Unexpected error in main test runner: {e}\")\n        return 1\n\n    # Print summary\n    print(\"\\n\" + \"=\" * 40)\n    print(\"=== TEST RESULTS ===\")\n    print(\"=\" * 40)\n\n    passed = sum(1 for result in test_results.values() if result is True)\n    total = sum(1 for result in test_results.values() if isinstance(result, bool))\n\n    print(f\"\\nSummary: {passed}/{total} tests passed\")\n\n    for test_name, result in test_results.items():\n        status = \"✓ PASS\" if result else \"✗ FAIL\"\n        color = '\\033[92m' if result else '\\033[91m'\n        reset = '\\033[0m'\n        print(f\"  {color}{status}{reset}: {test_name}\")\n\n    print(\"\\n\" + \"=\" * 40)\n\n    # Return exit code\n    if passed == total:\n        logger.success(\"All tests passed!\")\n        return 0\n    else:\n        logger.error(f\"{total - passed} test(s) failed\")\n        return 1",
          "filepath": "scripts/test_history_manager.py",
          "language": "python",
          "context": "main function"
        }
      ],
      "combined_code": "\n\n# ==================================================# filepath: scripts/test_history_manager.py\n# context: test_prune_context function\n\ndef test_prune_context() -> Dict[str, Any]:\n    \"\"\"Test context pruning for irrelevant tool results.\"\"\"\n    logger = logging.getLogger(__name__)\n    logger.info(\"Testing context pruning for irrelevant tool results...\")\n\n    try:\n        # Create test messages with tool results\n        messages = [\n            Message(id=\"1\", thread_id=\"test\", role=\"user\", content=\"Show me the auth service code\", tokens=0),\n            Message(id=\"2\", thread_id=\"test\", role=\"tool\", content=\"File: app/services/auth.py\\nCode: def authenticate(): ...\", tokens=0),\n            Message(id=\"3\", thread_id=\"test\", role=\"tool\", content=\"File: app/utils/logger.py\\nCode: def log(): ...\", tokens=0),\n            Message(id=\"4\", thread_id=\"test\", role=\"tool\", content=\"File: app/models/user.py\\nCode: class User: ...\", tokens=0),\n            Message(id=\"5\", thread_id=\"test\", role=\"assistant\", content=\"Here's the auth service code...\", tokens=0),\n            Message(id=\"6\", thread_id=\"test\", role=\"user\", content=\"Now modify only app/services/auth.py\", tokens=0),\n        ]\n\n        original_count = len(messages)\n        logger.info(f\"Original messages: {original_count}\")\n\n        # User query mentioning specific file\n        user_query = \"Modify the authenticate function in app/services/auth.py\"\n\n        # Apply pruning directly using the function\n        pruned_messages = prune_irrelevant_context(\n            history=messages,\n            current_query=user_query\n        )\n\n        pruned_count = len(pruned_messages)\n        pruned_tool_count = sum(1 for m in pruned_messages if m.content.startswith(\"[PRUNED\"))\n        logger.info(f\"After pruning: {pruned_count} messages\")\n        logger.info(f\"Pruned {pruned_tool_count} tool messages (content replaced)\")\n\n        # Verify irrelevant tool results were removed\n        tool_messages_before = [m for m in messages if m.role == \"tool\"]\n        tool_messages_after = [m for m in pruned_messages if m.role == \"tool\"]\n\n        # Check that relevant tool results (auth.py) kept original content\n        auth_tools = [m for m in tool_messages_after if \"auth.py\" in m.content and not m.content.startswith(\"[PRUNED\")]\n        \n        # Check that irrelevant tool results were pruned (content replaced with [PRUNED...])\n        pruned_tools = [m for m in tool_messages_after if m.content.startswith(\"[PRUNED\")]\n        \n        # Verify: auth.py tool should remain with original content\n        assert len(auth_tools) == 1, f\"Relevant tool result (auth.py) should remain unchanged, got {len(auth_tools)}\"\n        \n        # Verify: other tools (logger.py, user.py) should be pruned\n        assert len(pruned_tools) == 2, f\"Irrelevant tool results should be pruned, got {len(pruned_tools)}\"\n\n        logger.success(\"Context pruning test passed successfully\")\n\n        return {\n            \"original_count\": original_count,\n            \"final_count\": pruned_count,\n            \"pruned_tool_count\": len(pruned_tools),\n            \"relevant_tools_kept\": len(auth_tools),\n            \"files_mentioned\": [\"app/services/auth.py\"]\n        }\n\n    except AssertionError as e:\n        logger.error(f\"Assertion failed: {e}\")\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error in pruning test: {e}\")\n        raise\n\n# filepath: scripts/test_history_manager.py\n# context: main function\n\nasync def main() -> int:\n    \"\"\"Main test runner.\"\"\"\n    print(\"\\n\" + \"=\" * 40)\n    print(\"=== HISTORY MANAGEMENT TEST SUITE ===\")\n    print(\"=\" * 40 + \"\\n\")\n\n    # Setup logging\n    setup_logging()\n    logger = logging.getLogger(__name__)\n\n    # Test results tracker\n    test_results = {}\n\n    try:\n        # Test 1: Imports\n        logger.info(\"Starting test: Imports\")\n        test_results[\"imports\"] = test_imports()\n\n        if not test_results[\"imports\"]:\n            logger.error(\"Import test failed. Skipping further tests.\")\n            return 1\n\n        # Test 2: API Connection\n        logger.info(\"Starting test: API Connection\")\n        test_results[\"api_connection\"] = await test_api_connection()\n\n        if not test_results[\"api_connection\"]:\n            logger.warning(\"API connection test failed. Some tests may be limited.\")\n\n        # Test 3: Create History\n        logger.info(\"Starting test: Create History\")\n        try:\n            thread_id, manager = test_create_history()\n            test_results[\"create_history\"] = True\n        except Exception:\n            test_results[\"create_history\"] = False\n            thread_id, manager = None, None\n\n        # Test 4: History Compression (if history created successfully)\n        if test_results.get(\"create_history\") and thread_id and manager:\n            logger.info(\"Starting test: History Compression\")\n            try:\n                compression_stats = await test_history_compression(manager, thread_id)\n                test_results[\"history_compression\"] = compression_stats.get(\"compression_happened\", False)\n            except Exception:\n                test_results[\"history_compression\"] = False\n        else:\n            logger.warning(\"Skipping compression test - history creation failed\")\n            test_results[\"history_compression\"] = False\n\n        # Test 5: Prune Context\n        logger.info(\"Starting test: Prune Context\")\n        try:\n            prune_stats = test_prune_context()\n            test_results[\"prune_context\"] = prune_stats.get(\"pruned_tool_count\", 0) > 0\n        except Exception:\n            test_results[\"prune_context\"] = False\n\n        # Cleanup\n        logger.info(\"Starting cleanup\")\n        test_results[\"cleanup\"] = await cleanup_test_database()\n\n    except KeyboardInterrupt:\n        logger.error(\"Test suite interrupted by user\")\n        return 1\n    except Exception as e:\n        logger.exception(f\"Unexpected error in main test runner: {e}\")\n        return 1\n\n    # Print summary\n    print(\"\\n\" + \"=\" * 40)\n    print(\"=== TEST RESULTS ===\")\n    print(\"=\" * 40)\n\n    passed = sum(1 for result in test_results.values() if result is True)\n    total = sum(1 for result in test_results.values() if isinstance(result, bool))\n\n    print(f\"\\nSummary: {passed}/{total} tests passed\")\n\n    for test_name, result in test_results.items():\n        status = \"✓ PASS\" if result else \"✗ FAIL\"\n        color = '\\033[92m' if result else '\\033[91m'\n        reset = '\\033[0m'\n        print(f\"  {color}{status}{reset}: {test_name}\")\n\n    print(\"\\n\" + \"=\" * 40)\n\n    # Return exit code\n    if passed == total:\n        logger.success(\"All tests passed!\")\n        return 0\n    else:\n        logger.error(f\"{total - passed} test(s) failed\")\n        return 1",
      "explanation": "Этот код исправляет тест `test_prune_context()` в соответствии с реальным поведением функции `prune_irrelevant_context()`. Основные изменения:\n\n1. **Обновлён подсчёт сообщений**: Вместо подсчёта удалённых сообщений теперь подсчитываются сообщения с заменённым контентом (начинающимся с `[PRUNED`). Используется генераторное выражение `sum(1 for m in pruned_messages if m.content.startswith(\"[PRUNED\"))`.\n\n2. **Переписана логика проверки**: Теперь тест проверяет, что:\n   - Релевантные tool-сообщения (содержащие `auth.py`) сохранили оригинальный контент\n   - Нерелевантные tool-сообщения (содержащие `logger.py` и `user.py`) имеют контент, начинающийся с `[PRUNED`\n   - Добавлены конкретные проверки: должно остаться 1 неизменённое сообщение с `auth.py` и 2 \"подрезанных\" сообщения\n\n3. **Обновлён возвращаемый словарь**: Вместо `removed_count` теперь возвращаются:\n   - `final_count` - общее количество сообщений после обработки\n   - `pruned_tool_count` - количество tool-сообщений с заменённым контентом\n   - `relevant_tools_kept` - количество релевантных tool-сообщений с оригинальным контентом\n\n4. **Исправлена проверка в main()**: Теперь проверяется `pruned_tool_count > 0` вместо `removed_count > 0`, что корректно отражает поведение функции.\n\n**Важное замечание**: Функция `prune_irrelevant_context()` не удаляет сообщения из истории, а заменяет их контент на краткую метку `[PRUNED: ...]`. Это позволяет экономить токены, сохраняя при этом структуру диалога. Исправленный тест теперь правильно проверяет это поведение.",
      "error": null,
      "model_used": "deepseek-chat",
      "tokens_used": 0
    }
  }
}