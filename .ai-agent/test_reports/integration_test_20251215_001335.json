{
  "metadata": {
    "timestamp": "2025-12-15T00:13:35.974473",
    "project_dir": "C:\\Users\\Admin\\AI_Assistant_Pro",
    "user_query": "Создай класс HistoryManager в (сам файл тоже надо создать)файле app/history/manager.py, который станет единой точкой входа для работы с историей диалогов, объединяя HistoryStorage и модуль compressor. Реализуй асинхронный метод get_session_history(thread_id, current_query), который сначала загружает полную историю из БД, затем применяет compressor.compress_history_if_needed, и в конце выполняет compressor.prune_irrelevant_context, возвращая оптимизированный контекст \"на лету\" без сохранения изменений в базу. Добавь методы-обертки add_message, create_new_thread и list_user_threads, которые делегируют выполнение HistoryStorage, обеспечивая прозрачный доступ к данным. Менеджер должен инициализироваться настройками из config.settings (путь к БД, порог сжатия) и быть полностью асинхронным, чтобы не блокировать event loop при вызовах LLM-сжимателя. Обязательно реализуй надежную обработку ошибок: если сжатие или прунинг падают, метод get_session_history должен логировать ошибку и возвращать безопасную версию истории (например, последние N сообщений или полный список без обработки), чтобы не ломать работу Оркестратора. Весь код должен быть покрыт логированием (info/error) для отладки процессов сжатия и работы с БД.",
    "duration_seconds": 171.475243806839,
    "models_used": {
      "orchestrator": "Claude Sonnet 4.5 (RouterAI)",
      "code_generator": "deepseek-chat"
    }
  },
  "orchestrator": {
    "analysis": "Задача понятна: создать новый класс `HistoryManager` в новом файле `app/history/manager.py`, который будет фасадом для работы с историей диалогов. \n\n**Ключевые требования:**\n1. Создать новый файл с классом `HistoryManager`\n2. Интеграция с `HistoryStorage` и функциями из `compressor.py`\n3. Асинхронный метод `get_session_history` с fallback при ошибках\n4. Методы-обертки для делегирования в `HistoryStorage`\n5. Инициализация из `config.settings` (но настройки для истории там отсутствуют, поэтому используем значения по умолчанию)\n6. Полное логирование\n\n**Важные детали из анализа кода:**\n- `compress_history_if_needed` - **асинхронная** функция\n- `prune_irrelevant_context` - **синхронная** функция\n- `Message` - это `@dataclass` с полями: id, thread_id, role, content, tokens, metadata, created_at\n- `HistoryStorage` методы: `create_thread()`, `add_message()`, `get_messages()`, `list_threads()`\n- Константы: `DEFAULT_THRESHOLD = 30000`, `KEEP_LAST_N = 3`",
    "instruction": "**Task:** Создать новый класс HistoryManager для управления историей диалогов с интеграцией компрессии и прунинга контекста\n\n**File:** CREATE: app/history/manager.py\n\n**Location:** Новый файл, структура модуля верхнего уровня\n\n**Changes:**\n\n1. Добавить импорты в начало файла:\n   ```python\n   import logging\n   from typing import List, Optional, Dict, Any\n   from dataclasses import asdict\n   from app.history.storage import HistoryStorage, Message, Thread\n   from app.history.compressor import compress_history_if_needed, prune_irrelevant_context\n   from config.settings import cfg\n   ```\n\n2. Создать logger после импортов:\n   ```python\n   logger = logging.getLogger(__name__)\n   ```\n\n3. Создать класс `HistoryManager` с константами по умолчанию:\n   ```python\n   class HistoryManager:\n       \"\"\"\n       Единая точка входа для работы с историей диалогов.\n       Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n       \"\"\"\n       DEFAULT_DB_PATH = \"history.db\"\n       DEFAULT_COMPRESSION_THRESHOLD = 30000\n       DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n   ```\n\n4. Добавить метод `__init__` с инициализацией из настроек:\n   ```python\n   def __init__(\n       self,\n       db_path: Optional[str] = None,\n       compression_threshold: Optional[int] = None\n   ):\n       \"\"\"\n       Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n       \n       Args:\n           db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n           compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n       \"\"\"\n       # Получаем путь к БД из настроек или используем значение по умолчанию\n       self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n       \n       # Получаем порог сжатия из настроек или используем значение по умолчанию\n       self.compression_threshold = compression_threshold or getattr(\n           cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n       )\n       \n       # Инициализируем хранилище\n       self.storage = HistoryStorage(db_path=self.db_path)\n       \n       logger.info(\n           f\"HistoryManager initialized: db_path={self.db_path}, \"\n           f\"compression_threshold={self.compression_threshold}\"\n       )\n   ```\n\n5. Добавить асинхронный метод `get_session_history` с обработкой ошибок и fallback:\n   ```python\n   async def get_session_history(\n       self,\n       thread_id: str,\n       current_query: str\n   ) -> List[Message]:\n       \"\"\"\n       Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n       \n       Процесс:\n       1. Загружает полную историю из БД\n       2. Применяет сжатие (compress_history_if_needed)\n       3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n       \n       Args:\n           thread_id: ID диалога\n           current_query: Текущий запрос пользователя для определения релевантности\n           \n       Returns:\n           Оптимизированный список сообщений\n       \"\"\"\n       logger.info(f\"Loading session history for thread_id={thread_id}\")\n       \n       try:\n           # Шаг 1: Загрузка истории из БД\n           raw_history = self.storage.get_messages(thread_id)\n           logger.info(f\"Loaded {len(raw_history)} messages from database\")\n           \n           if not raw_history:\n               logger.warning(f\"No messages found for thread_id={thread_id}\")\n               return []\n           \n           # Шаг 2: Применение сжатия\n           try:\n               compressed_history = await compress_history_if_needed(\n                   raw_history,\n                   threshold=self.compression_threshold\n               )\n               logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n           except Exception as e:\n               logger.error(f\"Compression failed: {e}\", exc_info=True)\n               logger.warning(\"Falling back to raw history due to compression error\")\n               compressed_history = raw_history\n           \n           # Шаг 3: Применение прунинга нерелевантного контекста\n           try:\n               pruned_history = prune_irrelevant_context(compressed_history, current_query)\n               logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n           except Exception as e:\n               logger.error(f\"Pruning failed: {e}\", exc_info=True)\n               logger.warning(\"Falling back to compressed history due to pruning error\")\n               pruned_history = compressed_history\n           \n           return pruned_history\n           \n       except Exception as e:\n           logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n           logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n           \n           # Fallback: возвращаем последние N сообщений\n           try:\n               fallback_history = self.storage.get_messages(\n                   thread_id,\n                   limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n               )\n               logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n               return fallback_history\n           except Exception as fallback_error:\n               logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n               return []\n   ```\n\n6. Добавить метод-обертку `add_message`:\n   ```python\n   def add_message(\n       self,\n       thread_id: str,\n       role: str,\n       content: str,\n       tokens: int,\n       metadata: Optional[Dict[str, Any]] = None\n   ) -> Message:\n       \"\"\"\n       Добавляет сообщение в диалог (делегирует в HistoryStorage).\n       \n       Args:\n           thread_id: ID диалога\n           role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n           content: Текст сообщения\n           tokens: Количество токенов\n           metadata: Дополнительные метаданные\n           \n       Returns:\n           Созданный объект Message\n       \"\"\"\n       logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n       try:\n           message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n           logger.debug(f\"Message added successfully: message_id={message.id}\")\n           return message\n       except Exception as e:\n           logger.error(f\"Failed to add message: {e}\", exc_info=True)\n           raise\n   ```\n\n7. Добавить метод-обертку `create_new_thread`:\n   ```python\n   def create_new_thread(\n       self,\n       user_id: str,\n       project_path: Optional[str] = None,\n       title: str = \"Новый диалог\"\n   ) -> Thread:\n       \"\"\"\n       Создает новый диалог (делегирует в HistoryStorage).\n       \n       Args:\n           user_id: ID пользователя\n           project_path: Путь к проекту (опционально)\n           title: Заголовок диалога\n           \n       Returns:\n           Созданный объект Thread\n       \"\"\"\n       logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n       try:\n           thread = self.storage.create_thread(user_id, project_path, title)\n           logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n           return thread\n       except Exception as e:\n           logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n           raise\n   ```\n\n8. Добавить метод-обертку `list_user_threads`:\n   ```python\n   def list_user_threads(self, user_id: str) -> List[Thread]:\n       \"\"\"\n       Получает все диалоги пользователя (делегирует в HistoryStorage).\n       \n       Args:\n           user_id: ID пользователя\n           \n       Returns:\n           Список объектов Thread, отсортированных по дате обновления\n       \"\"\"\n       logger.info(f\"Listing threads for user_id={user_id}\")\n       try:\n           threads = self.storage.list_threads(user_id)\n           logger.info(f\"Found {len(threads)} threads for user_id={user_id}\")\n           return threads\n       except Exception as e:\n           logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n           raise\n   ```\n\n9. Добавить вспомогательный метод `get_thread` для полноты API:\n   ```python\n   def get_thread(self, thread_id: str) -> Optional[Thread]:\n       \"\"\"\n       Получает информацию о диалоге по ID (делегирует в HistoryStorage).\n       \n       Args:\n           thread_id: ID диалога\n           \n       Returns:\n           Объект Thread или None, если не найден\n       \"\"\"\n       logger.debug(f\"Getting thread info for thread_id={thread_id}\")\n       try:\n           thread = self.storage.get_thread(thread_id)\n           if thread:\n               logger.debug(f\"Thread found: {thread.title}\")\n           else:\n               logger.warning(f\"Thread not found: thread_id={thread_id}\")\n           return thread\n       except Exception as e:\n           logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n           raise\n   ```\n\n**Why:** Создание фасада `HistoryManager` обеспечивает единую точку входа для работы с историей диалогов, упрощая интеграцию с Orchestrator. Асинхронная обработка с надежным fallback гарантирует, что система продолжит работу даже при сбоях LLM-компрессора. Полное логирование позволяет отслеживать процессы сжатия и работы с БД для отладки."
  },
  "code_generator": {
    "code_blocks": [
      {
        "filepath": "app/history/manager.py",
        "language": "python",
        "code": "import logging\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import asdict\nfrom app.history.storage import HistoryStorage, Message, Thread\nfrom app.history.compressor import compress_history_if_needed, prune_irrelevant_context\nfrom config.settings import cfg\n\nlogger = logging.getLogger(__name__)\n\n\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_new_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise\n\n    def list_user_threads(self, user_id: str) -> List[Thread]:\n        \"\"\"\n        Получает все диалоги пользователя (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            \n        Returns:\n            Список объектов Thread, отсортированных по дате обновления\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}\")\n        try:\n            threads = self.storage.list_threads(user_id)\n            logger.info(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            raise\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает информацию о диалоге по ID (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            \n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread info for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread.title}\")\n            else:\n                logger.warning(f\"Thread not found: thread_id={thread_id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise",
        "context": null
      },
      {
        "filepath": "app/history/manager.py",
        "language": "python",
        "code": "# Инициализация менеджера\nmanager = HistoryManager()\n\n# Создание нового диалога\nthread = manager.create_new_thread(user_id=\"user123\")\n\n# Добавление сообщений\nmanager.add_message(\n    thread_id=thread.id,\n    role=\"user\",\n    content=\"Привет, как дела?\",\n    tokens=10\n)\n\n# Получение оптимизированной истории\nhistory = await manager.get_session_history(\n    thread_id=thread.id,\n    current_query=\"Какой у меня последний вопрос?\"\n)",
        "context": null
      }
    ],
    "explanation": "Этот код создает новый класс `HistoryManager`, который служит единой точкой входа для управления историей диалогов в приложении. Класс объединяет функциональность хранилища данных (`HistoryStorage`) и модуля компрессии (`compressor`), предоставляя удобный API для работы с историей.\n\n**Что делает код:**\n\n1. **Инициализация и настройки**: Класс инициализируется с настройками из конфигурации или значениями по умолчанию. Он автоматически создает экземпляр `HistoryStorage` для работы с базой данных.\n\n2. **Основной метод `get_session_history`**: Это асинхронный метод, который выполняет ключевую задачу — загружает и оптимизирует историю диалога. Процесс состоит из трех шагов:\n   - Загрузка полной истории из базы данных\n   - Сжатие истории с помощью LLM, если количество токенов превышает порог\n   - Удаление нерелевантного контекста на основе текущего запроса пользователя\n\n3. **Надежная обработка ошибок**: Метод включает несколько уровней fallback:\n   - Если сжатие не удается, используется исходная история\n   - Если прунинг не удается, используется сжатая история\n   - В случае критической ошибки возвращаются последние N сообщений (fallback)\n\n4. **Оберточные методы**: Класс предоставляет удобные методы для работы с хранилищем:\n   - `add_message()` — добавление нового сообщения\n   - `create_new_thread()` — создание нового диалога\n   - `list_user_threads()` — получение списка диалогов пользователя\n   - `get_thread()` — получение информации о конкретном диалоге\n\n**Почему этот подход работает:**\n\n- **Фасадный паттерн**: `HistoryManager` скрывает сложность работы с несколькими модулями (хранилище, компрессия) за простым интерфейсом\n- **Асинхронная обработка**: Сжатие истории выполняется асинхронно, что не блокирует основной поток приложения\n- **Отказоустойчивость**: Многоуровневый fallback гарантирует, что система продолжит работу даже при сбоях в LLM-компрессоре\n- **Полное логирование**: Каждый шаг процесса логируется, что упрощает отладку и мониторинг\n\n**Как использовать:**\n\n\n\n**Важные замечания:**\n\n- Класс зависит от корректной работы модулей `app.history.storage` и `app.history.compressor`\n- Метод `get_session_history` является асинхронным и должен вызываться с `await`\n- Значения по умолчанию для порога сжатия (30000 токенов) и fallback (10 сообщений) можно переопределить через конфигурацию\n- Логирование настроено на уровне модуля, что позволяет легко отслеживать процессы сжатия и работы с БД",
    "frontend_json": {
      "success": true,
      "code_blocks": [
        {
          "code": "import logging\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import asdict\nfrom app.history.storage import HistoryStorage, Message, Thread\nfrom app.history.compressor import compress_history_if_needed, prune_irrelevant_context\nfrom config.settings import cfg\n\nlogger = logging.getLogger(__name__)\n\n\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_new_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise\n\n    def list_user_threads(self, user_id: str) -> List[Thread]:\n        \"\"\"\n        Получает все диалоги пользователя (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            \n        Returns:\n            Список объектов Thread, отсортированных по дате обновления\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}\")\n        try:\n            threads = self.storage.list_threads(user_id)\n            logger.info(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            raise\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает информацию о диалоге по ID (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            \n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread info for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread.title}\")\n            else:\n                logger.warning(f\"Thread not found: thread_id={thread_id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise",
          "filepath": "app/history/manager.py",
          "language": "python",
          "context": null
        },
        {
          "code": "# Инициализация менеджера\nmanager = HistoryManager()\n\n# Создание нового диалога\nthread = manager.create_new_thread(user_id=\"user123\")\n\n# Добавление сообщений\nmanager.add_message(\n    thread_id=thread.id,\n    role=\"user\",\n    content=\"Привет, как дела?\",\n    tokens=10\n)\n\n# Получение оптимизированной истории\nhistory = await manager.get_session_history(\n    thread_id=thread.id,\n    current_query=\"Какой у меня последний вопрос?\"\n)",
          "filepath": "app/history/manager.py",
          "language": "python",
          "context": null
        }
      ],
      "combined_code": "\n\n# ==================================================# filepath: app/history/manager.py\n\nimport logging\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import asdict\nfrom app.history.storage import HistoryStorage, Message, Thread\nfrom app.history.compressor import compress_history_if_needed, prune_irrelevant_context\nfrom config.settings import cfg\n\nlogger = logging.getLogger(__name__)\n\n\nclass HistoryManager:\n    \"\"\"\n    Единая точка входа для работы с историей диалогов.\n    Объединяет HistoryStorage и модуль compressor для прозрачной работы с историей.\n    \"\"\"\n    DEFAULT_DB_PATH = \"history.db\"\n    DEFAULT_COMPRESSION_THRESHOLD = 30000\n    DEFAULT_FALLBACK_MESSAGE_COUNT = 10\n\n    def __init__(\n        self,\n        db_path: Optional[str] = None,\n        compression_threshold: Optional[int] = None\n    ):\n        \"\"\"\n        Инициализирует HistoryManager с настройками из config.settings или значениями по умолчанию.\n        \n        Args:\n            db_path: Путь к файлу БД SQLite (если None, берется из cfg или используется DEFAULT_DB_PATH)\n            compression_threshold: Порог токенов для сжатия (если None, используется DEFAULT_COMPRESSION_THRESHOLD)\n        \"\"\"\n        # Получаем путь к БД из настроек или используем значение по умолчанию\n        self.db_path = db_path or getattr(cfg, 'HISTORY_DB_PATH', self.DEFAULT_DB_PATH)\n        \n        # Получаем порог сжатия из настроек или используем значение по умолчанию\n        self.compression_threshold = compression_threshold or getattr(\n            cfg, 'HISTORY_COMPRESSION_THRESHOLD', self.DEFAULT_COMPRESSION_THRESHOLD\n        )\n        \n        # Инициализируем хранилище\n        self.storage = HistoryStorage(db_path=self.db_path)\n        \n        logger.info(\n            f\"HistoryManager initialized: db_path={self.db_path}, \"\n            f\"compression_threshold={self.compression_threshold}\"\n        )\n\n    async def get_session_history(\n        self,\n        thread_id: str,\n        current_query: str\n    ) -> List[Message]:\n        \"\"\"\n        Загружает и оптимизирует историю диалога \"на лету\" без сохранения в БД.\n        \n        Процесс:\n        1. Загружает полную историю из БД\n        2. Применяет сжатие (compress_history_if_needed)\n        3. Применяет прунинг нерелевантного контекста (prune_irrelevant_context)\n        \n        Args:\n            thread_id: ID диалога\n            current_query: Текущий запрос пользователя для определения релевантности\n            \n        Returns:\n            Оптимизированный список сообщений\n        \"\"\"\n        logger.info(f\"Loading session history for thread_id={thread_id}\")\n        \n        try:\n            # Шаг 1: Загрузка истории из БД\n            raw_history = self.storage.get_messages(thread_id)\n            logger.info(f\"Loaded {len(raw_history)} messages from database\")\n            \n            if not raw_history:\n                logger.warning(f\"No messages found for thread_id={thread_id}\")\n                return []\n            \n            # Шаг 2: Применение сжатия\n            try:\n                compressed_history = await compress_history_if_needed(\n                    raw_history,\n                    threshold=self.compression_threshold\n                )\n                logger.info(f\"Compression complete: {len(compressed_history)} messages after compression\")\n            except Exception as e:\n                logger.error(f\"Compression failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to raw history due to compression error\")\n                compressed_history = raw_history\n            \n            # Шаг 3: Применение прунинга нерелевантного контекста\n            try:\n                pruned_history = prune_irrelevant_context(compressed_history, current_query)\n                logger.info(f\"Pruning complete: {len(pruned_history)} messages after pruning\")\n            except Exception as e:\n                logger.error(f\"Pruning failed: {e}\", exc_info=True)\n                logger.warning(\"Falling back to compressed history due to pruning error\")\n                pruned_history = compressed_history\n            \n            return pruned_history\n            \n        except Exception as e:\n            logger.error(f\"Critical error in get_session_history: {e}\", exc_info=True)\n            logger.warning(f\"Falling back to last {self.DEFAULT_FALLBACK_MESSAGE_COUNT} messages\")\n            \n            # Fallback: возвращаем последние N сообщений\n            try:\n                fallback_history = self.storage.get_messages(\n                    thread_id,\n                    limit=self.DEFAULT_FALLBACK_MESSAGE_COUNT\n                )\n                logger.info(f\"Fallback successful: returning {len(fallback_history)} recent messages\")\n                return fallback_history\n            except Exception as fallback_error:\n                logger.error(f\"Fallback also failed: {fallback_error}\", exc_info=True)\n                return []\n\n    def add_message(\n        self,\n        thread_id: str,\n        role: str,\n        content: str,\n        tokens: int,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> Message:\n        \"\"\"\n        Добавляет сообщение в диалог (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            role: Роль отправителя ('user', 'assistant', 'tool', 'system')\n            content: Текст сообщения\n            tokens: Количество токенов\n            metadata: Дополнительные метаданные\n            \n        Returns:\n            Созданный объект Message\n        \"\"\"\n        logger.info(f\"Adding {role} message to thread_id={thread_id}, tokens={tokens}\")\n        try:\n            message = self.storage.add_message(thread_id, role, content, tokens, metadata)\n            logger.debug(f\"Message added successfully: message_id={message.id}\")\n            return message\n        except Exception as e:\n            logger.error(f\"Failed to add message: {e}\", exc_info=True)\n            raise\n\n    def create_new_thread(\n        self,\n        user_id: str,\n        project_path: Optional[str] = None,\n        title: str = \"Новый диалог\"\n    ) -> Thread:\n        \"\"\"\n        Создает новый диалог (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            project_path: Путь к проекту (опционально)\n            title: Заголовок диалога\n            \n        Returns:\n            Созданный объект Thread\n        \"\"\"\n        logger.info(f\"Creating new thread for user_id={user_id}, project_path={project_path}\")\n        try:\n            thread = self.storage.create_thread(user_id, project_path, title)\n            logger.info(f\"Thread created successfully: thread_id={thread.id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to create thread: {e}\", exc_info=True)\n            raise\n\n    def list_user_threads(self, user_id: str) -> List[Thread]:\n        \"\"\"\n        Получает все диалоги пользователя (делегирует в HistoryStorage).\n        \n        Args:\n            user_id: ID пользователя\n            \n        Returns:\n            Список объектов Thread, отсортированных по дате обновления\n        \"\"\"\n        logger.info(f\"Listing threads for user_id={user_id}\")\n        try:\n            threads = self.storage.list_threads(user_id)\n            logger.info(f\"Found {len(threads)} threads for user_id={user_id}\")\n            return threads\n        except Exception as e:\n            logger.error(f\"Failed to list threads: {e}\", exc_info=True)\n            raise\n\n    def get_thread(self, thread_id: str) -> Optional[Thread]:\n        \"\"\"\n        Получает информацию о диалоге по ID (делегирует в HistoryStorage).\n        \n        Args:\n            thread_id: ID диалога\n            \n        Returns:\n            Объект Thread или None, если не найден\n        \"\"\"\n        logger.debug(f\"Getting thread info for thread_id={thread_id}\")\n        try:\n            thread = self.storage.get_thread(thread_id)\n            if thread:\n                logger.debug(f\"Thread found: {thread.title}\")\n            else:\n                logger.warning(f\"Thread not found: thread_id={thread_id}\")\n            return thread\n        except Exception as e:\n            logger.error(f\"Failed to get thread: {e}\", exc_info=True)\n            raise\n\n# filepath: app/history/manager.py\n\n# Инициализация менеджера\nmanager = HistoryManager()\n\n# Создание нового диалога\nthread = manager.create_new_thread(user_id=\"user123\")\n\n# Добавление сообщений\nmanager.add_message(\n    thread_id=thread.id,\n    role=\"user\",\n    content=\"Привет, как дела?\",\n    tokens=10\n)\n\n# Получение оптимизированной истории\nhistory = await manager.get_session_history(\n    thread_id=thread.id,\n    current_query=\"Какой у меня последний вопрос?\"\n)",
      "explanation": "Этот код создает новый класс `HistoryManager`, который служит единой точкой входа для управления историей диалогов в приложении. Класс объединяет функциональность хранилища данных (`HistoryStorage`) и модуля компрессии (`compressor`), предоставляя удобный API для работы с историей.\n\n**Что делает код:**\n\n1. **Инициализация и настройки**: Класс инициализируется с настройками из конфигурации или значениями по умолчанию. Он автоматически создает экземпляр `HistoryStorage` для работы с базой данных.\n\n2. **Основной метод `get_session_history`**: Это асинхронный метод, который выполняет ключевую задачу — загружает и оптимизирует историю диалога. Процесс состоит из трех шагов:\n   - Загрузка полной истории из базы данных\n   - Сжатие истории с помощью LLM, если количество токенов превышает порог\n   - Удаление нерелевантного контекста на основе текущего запроса пользователя\n\n3. **Надежная обработка ошибок**: Метод включает несколько уровней fallback:\n   - Если сжатие не удается, используется исходная история\n   - Если прунинг не удается, используется сжатая история\n   - В случае критической ошибки возвращаются последние N сообщений (fallback)\n\n4. **Оберточные методы**: Класс предоставляет удобные методы для работы с хранилищем:\n   - `add_message()` — добавление нового сообщения\n   - `create_new_thread()` — создание нового диалога\n   - `list_user_threads()` — получение списка диалогов пользователя\n   - `get_thread()` — получение информации о конкретном диалоге\n\n**Почему этот подход работает:**\n\n- **Фасадный паттерн**: `HistoryManager` скрывает сложность работы с несколькими модулями (хранилище, компрессия) за простым интерфейсом\n- **Асинхронная обработка**: Сжатие истории выполняется асинхронно, что не блокирует основной поток приложения\n- **Отказоустойчивость**: Многоуровневый fallback гарантирует, что система продолжит работу даже при сбоях в LLM-компрессоре\n- **Полное логирование**: Каждый шаг процесса логируется, что упрощает отладку и мониторинг\n\n**Как использовать:**\n\n\n\n**Важные замечания:**\n\n- Класс зависит от корректной работы модулей `app.history.storage` и `app.history.compressor`\n- Метод `get_session_history` является асинхронным и должен вызываться с `await`\n- Значения по умолчанию для порога сжатия (30000 токенов) и fallback (10 сообщений) можно переопределить через конфигурацию\n- Логирование настроено на уровне модуля, что позволяет легко отслеживать процессы сжатия и работы с БД",
      "error": null,
      "model_used": "deepseek-chat",
      "tokens_used": 0
    }
  }
}