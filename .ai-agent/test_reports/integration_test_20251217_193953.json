{
  "metadata": {
    "timestamp": "2025-12-17T19:39:53.366200",
    "project_dir": "C:\\Users\\Admin\\AI_Assistant_Pro",
    "user_query": "Предложи улучшения для системы логирования",
    "duration_seconds": 204.3919038772583,
    "models_used": {
      "orchestrator": "Claude Sonnet 4.5 (RouterAI)",
      "code_generator": "deepseek-chat"
    }
  },
  "orchestrator": {
    "analysis": "**Текущее состояние системы логирования:**\n\nАнализ кодовой базы показывает следующие проблемы:\n\n1. **Отсутствие централизованной конфигурации** - логирование настраивается локально в тестовых скриптах (`test_agents.py`, `test_history_manager.py`), но нет единого модуля конфигурации для основного приложения\n2. **Разрозненная инициализация** - каждый модуль использует `logger = logging.getLogger(__name__)` без единой точки настройки\n3. **Нет структурированного логирования** - используется обычный текстовый формат, что затрудняет парсинг и анализ\n4. **Отсутствие контекстной информации** - нет trace ID для отслеживания цепочки вызовов в Orchestrator → Pre-filter → Code Generator\n5. **Нет ротации логов** - файлы могут расти бесконечно\n6. **Недостаточная детализация метрик** - нет агрегации статистики по LLM вызовам, токенам, стоимости\n7. **Нет разделения по окружениям** - одинаковые настройки для dev/prod\n\n**Рекомендуемые улучшения:**\n\n1. **Централизованная конфигурация** - создать `app/utils/logging_config.py`\n2. **Структурированное логирование** - добавить JSON формат для продакшена\n3. **Контекстные логи** - внедрить trace ID через contextvars\n4. **Ротация файлов** - использовать RotatingFileHandler\n5. **Метрики и мониторинг** - добавить агрегацию статистики\n6. **Разделение по уровням** - разные настройки для dev/prod через переменные окружения",
    "instruction": "**Task:** Создать централизованную систему логирования с поддержкой структурированных логов, контекстной информации (trace ID), ротации файлов и метрик\n\n---"
  },
  "code_generator": {
    "code_blocks": [
      {
        "filepath": "app/core/logging/logger.py",
        "language": "python",
        "code": "import logging\nimport logging.handlers\nimport json\nimport sys\nimport os\nimport time\nimport threading\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Union\nfrom uuid import uuid4\n\n\nclass StructuredLogger:\n    \"\"\"\n    Централизованный структурированный логгер с поддержкой trace ID, ротации файлов и метрик.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"app\",\n        log_file: str = \"logs/app.log\",\n        max_bytes: int = 10 * 1024 * 1024,  # 10 MB\n        backup_count: int = 5,\n        log_level: str = \"INFO\",\n        enable_console: bool = True,\n        enable_json: bool = True,\n    ):\n        self.name = name\n        self.log_file = log_file\n        self.enable_json = enable_json\n        self._trace_id = threading.local()\n        self._context = threading.local()\n        self._metrics = {}\n\n        # Создаем директорию для логов если её нет\n        log_dir = os.path.dirname(log_file)\n        if log_dir and not os.path.exists(log_dir):\n            os.makedirs(log_dir, exist_ok=True)\n\n        # Настраиваем логгер\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, log_level.upper()))\n        self.logger.handlers.clear()  # Убираем стандартные обработчики\n\n        # Форматтер для структурированных логов\n        if enable_json:\n            formatter = self._json_formatter\n        else:\n            formatter = logging.Formatter(\n                \"%(asctime)s - %(name)s - %(levelname)s - [%(trace_id)s] - %(message)s\"\n            )\n\n        # Обработчик для файла с ротацией\n        file_handler = logging.handlers.RotatingFileHandler(\n            filename=log_file,\n            maxBytes=max_bytes,\n            backupCount=backup_count,\n            encoding=\"utf-8\",\n        )\n        file_handler.setFormatter(formatter)\n        self.logger.addHandler(file_handler)\n\n        # Обработчик для консоли (опционально)\n        if enable_console:\n            console_handler = logging.StreamHandler(sys.stdout)\n            console_handler.setFormatter(formatter)\n            self.logger.addHandler(console_handler)\n\n    @property\n    def _json_formatter(self):\n        \"\"\"Создает JSON форматтер для структурированных логов.\"\"\"\n        class JsonFormatter(logging.Formatter):\n            def format(self, record):\n                log_data = {\n                    \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n                    \"logger\": record.name,\n                    \"level\": record.levelname,\n                    \"message\": record.getMessage(),\n                    \"trace_id\": getattr(record, \"trace_id\", \"no_trace\"),\n                    \"context\": getattr(record, \"context\", {}),\n                    \"module\": record.module,\n                    \"function\": record.funcName,\n                    \"line\": record.lineno,\n                }\n                # Добавляем дополнительные поля из record.args если они есть\n                if hasattr(record, \"extra_fields\"):\n                    log_data.update(record.extra_fields)\n                return json.dumps(log_data, ensure_ascii=False)\n        return JsonFormatter()\n\n    def set_trace_id(self, trace_id: Optional[str] = None) -> str:\n        \"\"\"\n        Устанавливает trace ID для текущего потока.\n        Если trace_id не передан, генерируется новый UUID.\n        \"\"\"\n        if trace_id is None:\n            trace_id = str(uuid4())\n        self._trace_id.value = trace_id\n        return trace_id\n\n    def get_trace_id(self) -> Optional[str]:\n        \"\"\"Возвращает trace ID текущего потока.\"\"\"\n        return getattr(self._trace_id, \"value\", None)\n\n    def add_context(self, **kwargs):\n        \"\"\"\n        Добавляет контекстную информацию для текущего потока.\n        \"\"\"\n        if not hasattr(self._context, \"value\"):\n            self._context.value = {}\n        self._context.value.update(kwargs)\n\n    def clear_context(self):\n        \"\"\"Очищает контекстную информацию для текущего потока.\"\"\"\n        if hasattr(self._context, \"value\"):\n            self._context.value.clear()\n\n    def _make_log_record(self, level: str, message: str, **kwargs):\n        \"\"\"\n        Создает запись лога с дополнительными полями.\n        \"\"\"\n        extra = {\n            \"trace_id\": self.get_trace_id() or \"no_trace\",\n            \"context\": getattr(self._context, \"value\", {}),\n        }\n        if kwargs:\n            extra[\"extra_fields\"] = kwargs\n\n        # Используем стандартный метод логирования с extra полями\n        log_method = getattr(self.logger, level.lower())\n        log_method(message, extra=extra)\n\n    def info(self, message: str, **kwargs):\n        \"\"\"Логирование информационного сообщения.\"\"\"\n        self._make_log_record(\"info\", message, **kwargs)\n\n    def warning(self, message: str, **kwargs):\n        \"\"\"Логирование предупреждения.\"\"\"\n        self._make_log_record(\"warning\", message, **kwargs)\n\n    def error(self, message: str, **kwargs):\n        \"\"\"Логирование ошибки.\"\"\"\n        self._make_log_record(\"error\", message, **kwargs)\n\n    def debug(self, message: str, **kwargs):\n        \"\"\"Логирование отладочной информации.\"\"\"\n        self._make_log_record(\"debug\", message, **kwargs)\n\n    def critical(self, message: str, **kwargs):\n        \"\"\"Логирование критической ошибки.\"\"\"\n        self._make_log_record(\"critical\", message, **kwargs)\n\n    def metric(self, name: str, value: float, tags: Optional[Dict[str, str]] = None):\n        \"\"\"\n        Регистрирует метрику.\n        Метрики хранятся в памяти и могут быть экспортированы отдельно.\n        \"\"\"\n        metric_key = f\"{name}_{time.time()}\"\n        self._metrics[metric_key] = {\n            \"name\": name,\n            \"value\": value,\n            \"tags\": tags or {},\n            \"timestamp\": time.time(),\n            \"trace_id\": self.get_trace_id(),\n        }\n        # Также логируем метрику как INFO сообщение\n        self.info(f\"Metric recorded: {name}={value}\", metric_name=name, metric_value=value, tags=tags)\n\n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Возвращает все зарегистрированные метрики.\"\"\"\n        return self._metrics.copy()\n\n    def clear_metrics(self):\n        \"\"\"Очищает все метрики.\"\"\"\n        self._metrics.clear()\n\n\n# Глобальный экземпляр логгера для удобного использования\n_logger_instance = None\n\n\ndef get_logger() -> StructuredLogger:\n    \"\"\"\n    Возвращает глобальный экземпляр логгера (синглтон).\n    \"\"\"\n    global _logger_instance\n    if _logger_instance is None:\n        _logger_instance = StructuredLogger()\n    return _logger_instance\n\n\ndef setup_logging(\n    log_file: str = \"logs/app.log\",\n    max_bytes: int = 10 * 1024 * 1024,\n    backup_count: int = 5,\n    log_level: str = \"INFO\",\n    enable_console: bool = True,\n    enable_json: bool = True,\n) -> StructuredLogger:\n    \"\"\"\n    Настраивает и возвращает глобальный логгер.\n    \"\"\"\n    global _logger_instance\n    _logger_instance = StructuredLogger(\n        name=\"app\",\n        log_file=log_file,\n        max_bytes=max_bytes,\n        backup_count=backup_count,\n        log_level=log_level,\n        enable_console=enable_console,\n        enable_json=enable_json,\n    )\n    return _logger_instance",
        "context": null
      },
      {
        "filepath": "app/core/logging/middleware.py",
        "language": "python",
        "code": "import time\nfrom typing import Callable\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom .logger import get_logger\n\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Middleware для автоматического логирования HTTP запросов и установки trace ID.\n    \"\"\"\n\n    def __init__(self, app, trace_header: str = \"X-Trace-ID\"):\n        super().__init__(app)\n        self.trace_header = trace_header\n        self.logger = get_logger()\n\n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        # Устанавливаем trace ID из заголовка или генерируем новый\n        trace_id = request.headers.get(self.trace_header)\n        trace_id = self.logger.set_trace_id(trace_id)\n\n        # Добавляем контекстную информацию\n        self.logger.add_context(\n            method=request.method,\n            url=str(request.url),\n            client_host=request.client.host if request.client else None,\n            user_agent=request.headers.get(\"user-agent\"),\n        )\n\n        # Логируем начало обработки запроса\n        start_time = time.time()\n        self.logger.info(f\"Request started: {request.method} {request.url.path}\")\n\n        try:\n            response = await call_next(request)\n            process_time = time.time() - start_time\n\n            # Добавляем trace ID в заголовки ответа\n            response.headers[self.trace_header] = trace_id\n\n            # Логируем успешное завершение\n            self.logger.info(\n                f\"Request completed: {request.method} {request.url.path}\",\n                status_code=response.status_code,\n                process_time_ms=round(process_time * 1000, 2),\n            )\n\n            # Регистрируем метрику времени выполнения\n            self.logger.metric(\n                name=\"http_request_duration_ms\",\n                value=process_time * 1000,\n                tags={\n                    \"method\": request.method,\n                    \"path\": request.url.path,\n                    \"status\": str(response.status_code),\n                },\n            )\n\n            return response\n\n        except Exception as e:\n            process_time = time.time() - start_time\n            # Логируем ошибку\n            self.logger.error(\n                f\"Request failed: {request.method} {request.url.path}\",\n                error_type=type(e).__name__,\n                error_message=str(e),\n                process_time_ms=round(process_time * 1000, 2),\n            )\n            raise\n\n        finally:\n            # Очищаем контекст для текущего запроса\n            self.logger.clear_context()",
        "context": null
      },
      {
        "filepath": "app/core/logging/__init__.py",
        "language": "python",
        "code": "\"\"\"\nПакет для централизованного логирования.\n\"\"\"\n\nfrom .logger import StructuredLogger, get_logger, setup_logging\nfrom .middleware import LoggingMiddleware\n\n__all__ = [\n    \"StructuredLogger\",\n    \"get_logger\",\n    \"setup_logging\",\n    \"LoggingMiddleware\",\n]",
        "context": null
      },
      {
        "filepath": "config/logging.yaml",
        "language": "yaml",
        "code": "# Конфигурация системы логирования\n\ndefault:\n  # Основные настройки\n  log_file: \"logs/app.log\"\n  max_bytes: 10485760  # 10 MB\n  backup_count: 5\n  log_level: \"INFO\"\n  enable_console: true\n  enable_json: true\n  \n  # Настройки trace ID\n  trace_header: \"X-Trace-ID\"\n  \n  # Настройки метрик\n  metrics:\n    enabled: true\n    flush_interval: 60  # секунды\n    \n  # Контекст по умолчанию\n  default_context:\n    app_name: \"my_application\"\n    environment: \"development\"\n\n# Настройки для разных окружений\ndevelopment:\n  log_level: \"DEBUG\"\n  enable_console: true\n  \nproduction:\n  log_level: \"WARNING\"\n  enable_console: false\n  log_file: \"/var/log/app/app.log\"\n  max_bytes: 52428800  # 50 MB\n  backup_count: 10\n\ntesting:\n  log_level: \"INFO\"\n  enable_console: false\n  log_file: \"logs/test.log\"",
        "context": null
      },
      {
        "filepath": "examples/logging_usage.py",
        "language": "python",
        "code": "\"\"\"\nПримеры использования системы логирования.\n\"\"\"\n\nimport asyncio\nfrom app.core.logging import get_logger, setup_logging, LoggingMiddleware\nfrom fastapi import FastAPI, Depends\n\n# 1. Базовая настройка\nlogger = setup_logging(\n    log_file=\"logs/myapp.log\",\n    log_level=\"DEBUG\",\n    enable_json=True\n)\n\n# 2. Простое использование\nlogger.info(\"Приложение запущено\", version=\"1.0.0\")\n\n# 3. Логирование с trace ID\nlogger.set_trace_id(\"user-123-session-456\")\nlogger.info(\"Пользователь выполнил действие\", action=\"login\", user_id=123)\n\n# 4. Добавление контекста\nlogger.add_context(user_id=123, session_id=\"abc123\")\nlogger.info(\"Контекст добавлен\")\n\n# 5. Логирование ошибок\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError as e:\n    logger.error(\"Ошибка деления на ноль\", exc_info=True)\n\n# 6. Регистрация метрик\nlogger.metric(\"api_response_time\", 150.5, tags={\"endpoint\": \"/users\", \"method\": \"GET\"})\n\n# 7. Использование в FastAPI приложении\napp = FastAPI()\napp.add_middleware(LoggingMiddleware)\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, logger=Depends(lambda: get_logger())):\n    logger.info(f\"Запрос пользователя {user_id}\")\n    # ... логика обработки ...\n    return {\"user_id\": user_id}\n\n# 8. Получение метрик\nmetrics = logger.get_metrics()\nprint(f\"Зарегистрировано метрик: {len(metrics)}\")\n\nif __name__ == \"__main__\":\n    print(\"Примеры использования системы логирования\")",
        "context": null
      }
    ],
    "explanation": "Этот код реализует централизованную систему логирования с поддержкой структурированных логов, контекстной информации, ротации файлов и метрик. Вот ключевые компоненты:\n\n**Основные файлы:**\n\n1. **logger.py** - Основной класс `StructuredLogger`:\n   - Поддерживает структурированные логи в JSON формате\n   - Реализует ротацию файлов через `RotatingFileHandler`\n   - Управляет trace ID через thread-local storage\n   - Позволяет добавлять контекстную информацию\n   - Включает систему метрик для мониторинга\n\n2. **middleware.py** - Middleware для веб-приложений:\n   - Автоматически устанавливает trace ID из заголовков HTTP\n   - Логирует начало и конец обработки запросов\n   - Измеряет время выполнения запросов\n   - Регистрирует метрики производительности\n\n3. **__init__.py** - Экспорт публичного API пакета\n\n4. **logging.yaml** - Конфигурационный файл:\n   - Настройки для разных окружений (development/production/testing)\n   - Параметры ротации файлов\n   - Конфигурация trace ID и метрик\n\n5. **logging_usage.py** - Примеры использования:\n   - Демонстрация всех возможностей системы\n   - Интеграция с FastAPI приложениями\n\n**Ключевые особенности:**\n\n- **Структурированные логи**: Все логи записываются в JSON формате, что упрощает их обработку и анализ\n- **Trace ID**: Каждый запрос получает уникальный идентификатор, позволяющий отслеживать цепочки событий\n- **Потокобезопасность**: Используется thread-local storage для изоляции контекста между потоками\n- **Ротация файлов**: Автоматическое управление размером лог-файлов с созданием бэкапов\n- **Метрики**: Встроенная система сбора метрик производительности\n- **Гибкая конфигурация**: Настройки через YAML файл для разных окружений\n\n**Использование:**\n1. Импортировать логгер: `from app.core.logging import get_logger`\n2. Настроить при запуске: `setup_logging()`\n3. Использовать методы `info()`, `error()`, `warning()` с дополнительными параметрами\n4. Для веб-приложений добавить `LoggingMiddleware`\n\nСистема обеспечивает единообразное логирование во всем приложении, упрощает отладку распределенных систем и предоставляет данные для мониторинга производительности.",
    "frontend_json": {
      "success": true,
      "code_blocks": [
        {
          "code": "import logging\nimport logging.handlers\nimport json\nimport sys\nimport os\nimport time\nimport threading\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Union\nfrom uuid import uuid4\n\n\nclass StructuredLogger:\n    \"\"\"\n    Централизованный структурированный логгер с поддержкой trace ID, ротации файлов и метрик.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"app\",\n        log_file: str = \"logs/app.log\",\n        max_bytes: int = 10 * 1024 * 1024,  # 10 MB\n        backup_count: int = 5,\n        log_level: str = \"INFO\",\n        enable_console: bool = True,\n        enable_json: bool = True,\n    ):\n        self.name = name\n        self.log_file = log_file\n        self.enable_json = enable_json\n        self._trace_id = threading.local()\n        self._context = threading.local()\n        self._metrics = {}\n\n        # Создаем директорию для логов если её нет\n        log_dir = os.path.dirname(log_file)\n        if log_dir and not os.path.exists(log_dir):\n            os.makedirs(log_dir, exist_ok=True)\n\n        # Настраиваем логгер\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, log_level.upper()))\n        self.logger.handlers.clear()  # Убираем стандартные обработчики\n\n        # Форматтер для структурированных логов\n        if enable_json:\n            formatter = self._json_formatter\n        else:\n            formatter = logging.Formatter(\n                \"%(asctime)s - %(name)s - %(levelname)s - [%(trace_id)s] - %(message)s\"\n            )\n\n        # Обработчик для файла с ротацией\n        file_handler = logging.handlers.RotatingFileHandler(\n            filename=log_file,\n            maxBytes=max_bytes,\n            backupCount=backup_count,\n            encoding=\"utf-8\",\n        )\n        file_handler.setFormatter(formatter)\n        self.logger.addHandler(file_handler)\n\n        # Обработчик для консоли (опционально)\n        if enable_console:\n            console_handler = logging.StreamHandler(sys.stdout)\n            console_handler.setFormatter(formatter)\n            self.logger.addHandler(console_handler)\n\n    @property\n    def _json_formatter(self):\n        \"\"\"Создает JSON форматтер для структурированных логов.\"\"\"\n        class JsonFormatter(logging.Formatter):\n            def format(self, record):\n                log_data = {\n                    \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n                    \"logger\": record.name,\n                    \"level\": record.levelname,\n                    \"message\": record.getMessage(),\n                    \"trace_id\": getattr(record, \"trace_id\", \"no_trace\"),\n                    \"context\": getattr(record, \"context\", {}),\n                    \"module\": record.module,\n                    \"function\": record.funcName,\n                    \"line\": record.lineno,\n                }\n                # Добавляем дополнительные поля из record.args если они есть\n                if hasattr(record, \"extra_fields\"):\n                    log_data.update(record.extra_fields)\n                return json.dumps(log_data, ensure_ascii=False)\n        return JsonFormatter()\n\n    def set_trace_id(self, trace_id: Optional[str] = None) -> str:\n        \"\"\"\n        Устанавливает trace ID для текущего потока.\n        Если trace_id не передан, генерируется новый UUID.\n        \"\"\"\n        if trace_id is None:\n            trace_id = str(uuid4())\n        self._trace_id.value = trace_id\n        return trace_id\n\n    def get_trace_id(self) -> Optional[str]:\n        \"\"\"Возвращает trace ID текущего потока.\"\"\"\n        return getattr(self._trace_id, \"value\", None)\n\n    def add_context(self, **kwargs):\n        \"\"\"\n        Добавляет контекстную информацию для текущего потока.\n        \"\"\"\n        if not hasattr(self._context, \"value\"):\n            self._context.value = {}\n        self._context.value.update(kwargs)\n\n    def clear_context(self):\n        \"\"\"Очищает контекстную информацию для текущего потока.\"\"\"\n        if hasattr(self._context, \"value\"):\n            self._context.value.clear()\n\n    def _make_log_record(self, level: str, message: str, **kwargs):\n        \"\"\"\n        Создает запись лога с дополнительными полями.\n        \"\"\"\n        extra = {\n            \"trace_id\": self.get_trace_id() or \"no_trace\",\n            \"context\": getattr(self._context, \"value\", {}),\n        }\n        if kwargs:\n            extra[\"extra_fields\"] = kwargs\n\n        # Используем стандартный метод логирования с extra полями\n        log_method = getattr(self.logger, level.lower())\n        log_method(message, extra=extra)\n\n    def info(self, message: str, **kwargs):\n        \"\"\"Логирование информационного сообщения.\"\"\"\n        self._make_log_record(\"info\", message, **kwargs)\n\n    def warning(self, message: str, **kwargs):\n        \"\"\"Логирование предупреждения.\"\"\"\n        self._make_log_record(\"warning\", message, **kwargs)\n\n    def error(self, message: str, **kwargs):\n        \"\"\"Логирование ошибки.\"\"\"\n        self._make_log_record(\"error\", message, **kwargs)\n\n    def debug(self, message: str, **kwargs):\n        \"\"\"Логирование отладочной информации.\"\"\"\n        self._make_log_record(\"debug\", message, **kwargs)\n\n    def critical(self, message: str, **kwargs):\n        \"\"\"Логирование критической ошибки.\"\"\"\n        self._make_log_record(\"critical\", message, **kwargs)\n\n    def metric(self, name: str, value: float, tags: Optional[Dict[str, str]] = None):\n        \"\"\"\n        Регистрирует метрику.\n        Метрики хранятся в памяти и могут быть экспортированы отдельно.\n        \"\"\"\n        metric_key = f\"{name}_{time.time()}\"\n        self._metrics[metric_key] = {\n            \"name\": name,\n            \"value\": value,\n            \"tags\": tags or {},\n            \"timestamp\": time.time(),\n            \"trace_id\": self.get_trace_id(),\n        }\n        # Также логируем метрику как INFO сообщение\n        self.info(f\"Metric recorded: {name}={value}\", metric_name=name, metric_value=value, tags=tags)\n\n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Возвращает все зарегистрированные метрики.\"\"\"\n        return self._metrics.copy()\n\n    def clear_metrics(self):\n        \"\"\"Очищает все метрики.\"\"\"\n        self._metrics.clear()\n\n\n# Глобальный экземпляр логгера для удобного использования\n_logger_instance = None\n\n\ndef get_logger() -> StructuredLogger:\n    \"\"\"\n    Возвращает глобальный экземпляр логгера (синглтон).\n    \"\"\"\n    global _logger_instance\n    if _logger_instance is None:\n        _logger_instance = StructuredLogger()\n    return _logger_instance\n\n\ndef setup_logging(\n    log_file: str = \"logs/app.log\",\n    max_bytes: int = 10 * 1024 * 1024,\n    backup_count: int = 5,\n    log_level: str = \"INFO\",\n    enable_console: bool = True,\n    enable_json: bool = True,\n) -> StructuredLogger:\n    \"\"\"\n    Настраивает и возвращает глобальный логгер.\n    \"\"\"\n    global _logger_instance\n    _logger_instance = StructuredLogger(\n        name=\"app\",\n        log_file=log_file,\n        max_bytes=max_bytes,\n        backup_count=backup_count,\n        log_level=log_level,\n        enable_console=enable_console,\n        enable_json=enable_json,\n    )\n    return _logger_instance",
          "filepath": "app/core/logging/logger.py",
          "language": "python",
          "context": null
        },
        {
          "code": "import time\nfrom typing import Callable\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom .logger import get_logger\n\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Middleware для автоматического логирования HTTP запросов и установки trace ID.\n    \"\"\"\n\n    def __init__(self, app, trace_header: str = \"X-Trace-ID\"):\n        super().__init__(app)\n        self.trace_header = trace_header\n        self.logger = get_logger()\n\n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        # Устанавливаем trace ID из заголовка или генерируем новый\n        trace_id = request.headers.get(self.trace_header)\n        trace_id = self.logger.set_trace_id(trace_id)\n\n        # Добавляем контекстную информацию\n        self.logger.add_context(\n            method=request.method,\n            url=str(request.url),\n            client_host=request.client.host if request.client else None,\n            user_agent=request.headers.get(\"user-agent\"),\n        )\n\n        # Логируем начало обработки запроса\n        start_time = time.time()\n        self.logger.info(f\"Request started: {request.method} {request.url.path}\")\n\n        try:\n            response = await call_next(request)\n            process_time = time.time() - start_time\n\n            # Добавляем trace ID в заголовки ответа\n            response.headers[self.trace_header] = trace_id\n\n            # Логируем успешное завершение\n            self.logger.info(\n                f\"Request completed: {request.method} {request.url.path}\",\n                status_code=response.status_code,\n                process_time_ms=round(process_time * 1000, 2),\n            )\n\n            # Регистрируем метрику времени выполнения\n            self.logger.metric(\n                name=\"http_request_duration_ms\",\n                value=process_time * 1000,\n                tags={\n                    \"method\": request.method,\n                    \"path\": request.url.path,\n                    \"status\": str(response.status_code),\n                },\n            )\n\n            return response\n\n        except Exception as e:\n            process_time = time.time() - start_time\n            # Логируем ошибку\n            self.logger.error(\n                f\"Request failed: {request.method} {request.url.path}\",\n                error_type=type(e).__name__,\n                error_message=str(e),\n                process_time_ms=round(process_time * 1000, 2),\n            )\n            raise\n\n        finally:\n            # Очищаем контекст для текущего запроса\n            self.logger.clear_context()",
          "filepath": "app/core/logging/middleware.py",
          "language": "python",
          "context": null
        },
        {
          "code": "\"\"\"\nПакет для централизованного логирования.\n\"\"\"\n\nfrom .logger import StructuredLogger, get_logger, setup_logging\nfrom .middleware import LoggingMiddleware\n\n__all__ = [\n    \"StructuredLogger\",\n    \"get_logger\",\n    \"setup_logging\",\n    \"LoggingMiddleware\",\n]",
          "filepath": "app/core/logging/__init__.py",
          "language": "python",
          "context": null
        },
        {
          "code": "# Конфигурация системы логирования\n\ndefault:\n  # Основные настройки\n  log_file: \"logs/app.log\"\n  max_bytes: 10485760  # 10 MB\n  backup_count: 5\n  log_level: \"INFO\"\n  enable_console: true\n  enable_json: true\n  \n  # Настройки trace ID\n  trace_header: \"X-Trace-ID\"\n  \n  # Настройки метрик\n  metrics:\n    enabled: true\n    flush_interval: 60  # секунды\n    \n  # Контекст по умолчанию\n  default_context:\n    app_name: \"my_application\"\n    environment: \"development\"\n\n# Настройки для разных окружений\ndevelopment:\n  log_level: \"DEBUG\"\n  enable_console: true\n  \nproduction:\n  log_level: \"WARNING\"\n  enable_console: false\n  log_file: \"/var/log/app/app.log\"\n  max_bytes: 52428800  # 50 MB\n  backup_count: 10\n\ntesting:\n  log_level: \"INFO\"\n  enable_console: false\n  log_file: \"logs/test.log\"",
          "filepath": "config/logging.yaml",
          "language": "yaml",
          "context": null
        },
        {
          "code": "\"\"\"\nПримеры использования системы логирования.\n\"\"\"\n\nimport asyncio\nfrom app.core.logging import get_logger, setup_logging, LoggingMiddleware\nfrom fastapi import FastAPI, Depends\n\n# 1. Базовая настройка\nlogger = setup_logging(\n    log_file=\"logs/myapp.log\",\n    log_level=\"DEBUG\",\n    enable_json=True\n)\n\n# 2. Простое использование\nlogger.info(\"Приложение запущено\", version=\"1.0.0\")\n\n# 3. Логирование с trace ID\nlogger.set_trace_id(\"user-123-session-456\")\nlogger.info(\"Пользователь выполнил действие\", action=\"login\", user_id=123)\n\n# 4. Добавление контекста\nlogger.add_context(user_id=123, session_id=\"abc123\")\nlogger.info(\"Контекст добавлен\")\n\n# 5. Логирование ошибок\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError as e:\n    logger.error(\"Ошибка деления на ноль\", exc_info=True)\n\n# 6. Регистрация метрик\nlogger.metric(\"api_response_time\", 150.5, tags={\"endpoint\": \"/users\", \"method\": \"GET\"})\n\n# 7. Использование в FastAPI приложении\napp = FastAPI()\napp.add_middleware(LoggingMiddleware)\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, logger=Depends(lambda: get_logger())):\n    logger.info(f\"Запрос пользователя {user_id}\")\n    # ... логика обработки ...\n    return {\"user_id\": user_id}\n\n# 8. Получение метрик\nmetrics = logger.get_metrics()\nprint(f\"Зарегистрировано метрик: {len(metrics)}\")\n\nif __name__ == \"__main__\":\n    print(\"Примеры использования системы логирования\")",
          "filepath": "examples/logging_usage.py",
          "language": "python",
          "context": null
        }
      ],
      "combined_code": "\n\n# ==================================================# filepath: app/core/logging/logger.py\n\nimport logging\nimport logging.handlers\nimport json\nimport sys\nimport os\nimport time\nimport threading\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional, Union\nfrom uuid import uuid4\n\n\nclass StructuredLogger:\n    \"\"\"\n    Централизованный структурированный логгер с поддержкой trace ID, ротации файлов и метрик.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"app\",\n        log_file: str = \"logs/app.log\",\n        max_bytes: int = 10 * 1024 * 1024,  # 10 MB\n        backup_count: int = 5,\n        log_level: str = \"INFO\",\n        enable_console: bool = True,\n        enable_json: bool = True,\n    ):\n        self.name = name\n        self.log_file = log_file\n        self.enable_json = enable_json\n        self._trace_id = threading.local()\n        self._context = threading.local()\n        self._metrics = {}\n\n        # Создаем директорию для логов если её нет\n        log_dir = os.path.dirname(log_file)\n        if log_dir and not os.path.exists(log_dir):\n            os.makedirs(log_dir, exist_ok=True)\n\n        # Настраиваем логгер\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, log_level.upper()))\n        self.logger.handlers.clear()  # Убираем стандартные обработчики\n\n        # Форматтер для структурированных логов\n        if enable_json:\n            formatter = self._json_formatter\n        else:\n            formatter = logging.Formatter(\n                \"%(asctime)s - %(name)s - %(levelname)s - [%(trace_id)s] - %(message)s\"\n            )\n\n        # Обработчик для файла с ротацией\n        file_handler = logging.handlers.RotatingFileHandler(\n            filename=log_file,\n            maxBytes=max_bytes,\n            backupCount=backup_count,\n            encoding=\"utf-8\",\n        )\n        file_handler.setFormatter(formatter)\n        self.logger.addHandler(file_handler)\n\n        # Обработчик для консоли (опционально)\n        if enable_console:\n            console_handler = logging.StreamHandler(sys.stdout)\n            console_handler.setFormatter(formatter)\n            self.logger.addHandler(console_handler)\n\n    @property\n    def _json_formatter(self):\n        \"\"\"Создает JSON форматтер для структурированных логов.\"\"\"\n        class JsonFormatter(logging.Formatter):\n            def format(self, record):\n                log_data = {\n                    \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n                    \"logger\": record.name,\n                    \"level\": record.levelname,\n                    \"message\": record.getMessage(),\n                    \"trace_id\": getattr(record, \"trace_id\", \"no_trace\"),\n                    \"context\": getattr(record, \"context\", {}),\n                    \"module\": record.module,\n                    \"function\": record.funcName,\n                    \"line\": record.lineno,\n                }\n                # Добавляем дополнительные поля из record.args если они есть\n                if hasattr(record, \"extra_fields\"):\n                    log_data.update(record.extra_fields)\n                return json.dumps(log_data, ensure_ascii=False)\n        return JsonFormatter()\n\n    def set_trace_id(self, trace_id: Optional[str] = None) -> str:\n        \"\"\"\n        Устанавливает trace ID для текущего потока.\n        Если trace_id не передан, генерируется новый UUID.\n        \"\"\"\n        if trace_id is None:\n            trace_id = str(uuid4())\n        self._trace_id.value = trace_id\n        return trace_id\n\n    def get_trace_id(self) -> Optional[str]:\n        \"\"\"Возвращает trace ID текущего потока.\"\"\"\n        return getattr(self._trace_id, \"value\", None)\n\n    def add_context(self, **kwargs):\n        \"\"\"\n        Добавляет контекстную информацию для текущего потока.\n        \"\"\"\n        if not hasattr(self._context, \"value\"):\n            self._context.value = {}\n        self._context.value.update(kwargs)\n\n    def clear_context(self):\n        \"\"\"Очищает контекстную информацию для текущего потока.\"\"\"\n        if hasattr(self._context, \"value\"):\n            self._context.value.clear()\n\n    def _make_log_record(self, level: str, message: str, **kwargs):\n        \"\"\"\n        Создает запись лога с дополнительными полями.\n        \"\"\"\n        extra = {\n            \"trace_id\": self.get_trace_id() or \"no_trace\",\n            \"context\": getattr(self._context, \"value\", {}),\n        }\n        if kwargs:\n            extra[\"extra_fields\"] = kwargs\n\n        # Используем стандартный метод логирования с extra полями\n        log_method = getattr(self.logger, level.lower())\n        log_method(message, extra=extra)\n\n    def info(self, message: str, **kwargs):\n        \"\"\"Логирование информационного сообщения.\"\"\"\n        self._make_log_record(\"info\", message, **kwargs)\n\n    def warning(self, message: str, **kwargs):\n        \"\"\"Логирование предупреждения.\"\"\"\n        self._make_log_record(\"warning\", message, **kwargs)\n\n    def error(self, message: str, **kwargs):\n        \"\"\"Логирование ошибки.\"\"\"\n        self._make_log_record(\"error\", message, **kwargs)\n\n    def debug(self, message: str, **kwargs):\n        \"\"\"Логирование отладочной информации.\"\"\"\n        self._make_log_record(\"debug\", message, **kwargs)\n\n    def critical(self, message: str, **kwargs):\n        \"\"\"Логирование критической ошибки.\"\"\"\n        self._make_log_record(\"critical\", message, **kwargs)\n\n    def metric(self, name: str, value: float, tags: Optional[Dict[str, str]] = None):\n        \"\"\"\n        Регистрирует метрику.\n        Метрики хранятся в памяти и могут быть экспортированы отдельно.\n        \"\"\"\n        metric_key = f\"{name}_{time.time()}\"\n        self._metrics[metric_key] = {\n            \"name\": name,\n            \"value\": value,\n            \"tags\": tags or {},\n            \"timestamp\": time.time(),\n            \"trace_id\": self.get_trace_id(),\n        }\n        # Также логируем метрику как INFO сообщение\n        self.info(f\"Metric recorded: {name}={value}\", metric_name=name, metric_value=value, tags=tags)\n\n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Возвращает все зарегистрированные метрики.\"\"\"\n        return self._metrics.copy()\n\n    def clear_metrics(self):\n        \"\"\"Очищает все метрики.\"\"\"\n        self._metrics.clear()\n\n\n# Глобальный экземпляр логгера для удобного использования\n_logger_instance = None\n\n\ndef get_logger() -> StructuredLogger:\n    \"\"\"\n    Возвращает глобальный экземпляр логгера (синглтон).\n    \"\"\"\n    global _logger_instance\n    if _logger_instance is None:\n        _logger_instance = StructuredLogger()\n    return _logger_instance\n\n\ndef setup_logging(\n    log_file: str = \"logs/app.log\",\n    max_bytes: int = 10 * 1024 * 1024,\n    backup_count: int = 5,\n    log_level: str = \"INFO\",\n    enable_console: bool = True,\n    enable_json: bool = True,\n) -> StructuredLogger:\n    \"\"\"\n    Настраивает и возвращает глобальный логгер.\n    \"\"\"\n    global _logger_instance\n    _logger_instance = StructuredLogger(\n        name=\"app\",\n        log_file=log_file,\n        max_bytes=max_bytes,\n        backup_count=backup_count,\n        log_level=log_level,\n        enable_console=enable_console,\n        enable_json=enable_json,\n    )\n    return _logger_instance\n\n# filepath: app/core/logging/middleware.py\n\nimport time\nfrom typing import Callable\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom .logger import get_logger\n\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Middleware для автоматического логирования HTTP запросов и установки trace ID.\n    \"\"\"\n\n    def __init__(self, app, trace_header: str = \"X-Trace-ID\"):\n        super().__init__(app)\n        self.trace_header = trace_header\n        self.logger = get_logger()\n\n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        # Устанавливаем trace ID из заголовка или генерируем новый\n        trace_id = request.headers.get(self.trace_header)\n        trace_id = self.logger.set_trace_id(trace_id)\n\n        # Добавляем контекстную информацию\n        self.logger.add_context(\n            method=request.method,\n            url=str(request.url),\n            client_host=request.client.host if request.client else None,\n            user_agent=request.headers.get(\"user-agent\"),\n        )\n\n        # Логируем начало обработки запроса\n        start_time = time.time()\n        self.logger.info(f\"Request started: {request.method} {request.url.path}\")\n\n        try:\n            response = await call_next(request)\n            process_time = time.time() - start_time\n\n            # Добавляем trace ID в заголовки ответа\n            response.headers[self.trace_header] = trace_id\n\n            # Логируем успешное завершение\n            self.logger.info(\n                f\"Request completed: {request.method} {request.url.path}\",\n                status_code=response.status_code,\n                process_time_ms=round(process_time * 1000, 2),\n            )\n\n            # Регистрируем метрику времени выполнения\n            self.logger.metric(\n                name=\"http_request_duration_ms\",\n                value=process_time * 1000,\n                tags={\n                    \"method\": request.method,\n                    \"path\": request.url.path,\n                    \"status\": str(response.status_code),\n                },\n            )\n\n            return response\n\n        except Exception as e:\n            process_time = time.time() - start_time\n            # Логируем ошибку\n            self.logger.error(\n                f\"Request failed: {request.method} {request.url.path}\",\n                error_type=type(e).__name__,\n                error_message=str(e),\n                process_time_ms=round(process_time * 1000, 2),\n            )\n            raise\n\n        finally:\n            # Очищаем контекст для текущего запроса\n            self.logger.clear_context()\n\n# filepath: app/core/logging/__init__.py\n\n\"\"\"\nПакет для централизованного логирования.\n\"\"\"\n\nfrom .logger import StructuredLogger, get_logger, setup_logging\nfrom .middleware import LoggingMiddleware\n\n__all__ = [\n    \"StructuredLogger\",\n    \"get_logger\",\n    \"setup_logging\",\n    \"LoggingMiddleware\",\n]\n\n# filepath: config/logging.yaml\n\n# Конфигурация системы логирования\n\ndefault:\n  # Основные настройки\n  log_file: \"logs/app.log\"\n  max_bytes: 10485760  # 10 MB\n  backup_count: 5\n  log_level: \"INFO\"\n  enable_console: true\n  enable_json: true\n  \n  # Настройки trace ID\n  trace_header: \"X-Trace-ID\"\n  \n  # Настройки метрик\n  metrics:\n    enabled: true\n    flush_interval: 60  # секунды\n    \n  # Контекст по умолчанию\n  default_context:\n    app_name: \"my_application\"\n    environment: \"development\"\n\n# Настройки для разных окружений\ndevelopment:\n  log_level: \"DEBUG\"\n  enable_console: true\n  \nproduction:\n  log_level: \"WARNING\"\n  enable_console: false\n  log_file: \"/var/log/app/app.log\"\n  max_bytes: 52428800  # 50 MB\n  backup_count: 10\n\ntesting:\n  log_level: \"INFO\"\n  enable_console: false\n  log_file: \"logs/test.log\"\n\n# filepath: examples/logging_usage.py\n\n\"\"\"\nПримеры использования системы логирования.\n\"\"\"\n\nimport asyncio\nfrom app.core.logging import get_logger, setup_logging, LoggingMiddleware\nfrom fastapi import FastAPI, Depends\n\n# 1. Базовая настройка\nlogger = setup_logging(\n    log_file=\"logs/myapp.log\",\n    log_level=\"DEBUG\",\n    enable_json=True\n)\n\n# 2. Простое использование\nlogger.info(\"Приложение запущено\", version=\"1.0.0\")\n\n# 3. Логирование с trace ID\nlogger.set_trace_id(\"user-123-session-456\")\nlogger.info(\"Пользователь выполнил действие\", action=\"login\", user_id=123)\n\n# 4. Добавление контекста\nlogger.add_context(user_id=123, session_id=\"abc123\")\nlogger.info(\"Контекст добавлен\")\n\n# 5. Логирование ошибок\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError as e:\n    logger.error(\"Ошибка деления на ноль\", exc_info=True)\n\n# 6. Регистрация метрик\nlogger.metric(\"api_response_time\", 150.5, tags={\"endpoint\": \"/users\", \"method\": \"GET\"})\n\n# 7. Использование в FastAPI приложении\napp = FastAPI()\napp.add_middleware(LoggingMiddleware)\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, logger=Depends(lambda: get_logger())):\n    logger.info(f\"Запрос пользователя {user_id}\")\n    # ... логика обработки ...\n    return {\"user_id\": user_id}\n\n# 8. Получение метрик\nmetrics = logger.get_metrics()\nprint(f\"Зарегистрировано метрик: {len(metrics)}\")\n\nif __name__ == \"__main__\":\n    print(\"Примеры использования системы логирования\")",
      "explanation": "Этот код реализует централизованную систему логирования с поддержкой структурированных логов, контекстной информации, ротации файлов и метрик. Вот ключевые компоненты:\n\n**Основные файлы:**\n\n1. **logger.py** - Основной класс `StructuredLogger`:\n   - Поддерживает структурированные логи в JSON формате\n   - Реализует ротацию файлов через `RotatingFileHandler`\n   - Управляет trace ID через thread-local storage\n   - Позволяет добавлять контекстную информацию\n   - Включает систему метрик для мониторинга\n\n2. **middleware.py** - Middleware для веб-приложений:\n   - Автоматически устанавливает trace ID из заголовков HTTP\n   - Логирует начало и конец обработки запросов\n   - Измеряет время выполнения запросов\n   - Регистрирует метрики производительности\n\n3. **__init__.py** - Экспорт публичного API пакета\n\n4. **logging.yaml** - Конфигурационный файл:\n   - Настройки для разных окружений (development/production/testing)\n   - Параметры ротации файлов\n   - Конфигурация trace ID и метрик\n\n5. **logging_usage.py** - Примеры использования:\n   - Демонстрация всех возможностей системы\n   - Интеграция с FastAPI приложениями\n\n**Ключевые особенности:**\n\n- **Структурированные логи**: Все логи записываются в JSON формате, что упрощает их обработку и анализ\n- **Trace ID**: Каждый запрос получает уникальный идентификатор, позволяющий отслеживать цепочки событий\n- **Потокобезопасность**: Используется thread-local storage для изоляции контекста между потоками\n- **Ротация файлов**: Автоматическое управление размером лог-файлов с созданием бэкапов\n- **Метрики**: Встроенная система сбора метрик производительности\n- **Гибкая конфигурация**: Настройки через YAML файл для разных окружений\n\n**Использование:**\n1. Импортировать логгер: `from app.core.logging import get_logger`\n2. Настроить при запуске: `setup_logging()`\n3. Использовать методы `info()`, `error()`, `warning()` с дополнительными параметрами\n4. Для веб-приложений добавить `LoggingMiddleware`\n\nСистема обеспечивает единообразное логирование во всем приложении, упрощает отладку распределенных систем и предоставляет данные для мониторинга производительности.",
      "error": null,
      "model_used": "deepseek-chat",
      "tokens_used": 0
    }
  }
}